<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>消息队列</title>
      <link href="2020/11/05/mq/"/>
      <url>2020/11/05/mq/</url>
      
        <content type="html"><![CDATA[<p>消息队列</p><a id="more"></a><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>优点：可靠性；灵活的路由；高可用；消息集群；</p><h3 id="Exchange-类型"><a href="#Exchange-类型" class="headerlink" title="Exchange 类型"></a>Exchange 类型</h3><p><strong>direct</strong>，<strong>topic</strong>，<strong>fanout</strong>，<strong>heads</strong></p><h3 id="事务机制与"><a href="#事务机制与" class="headerlink" title="事务机制与"></a>事务机制与</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message, Channel channel)</span></span>&#123;</span><br><span class="line">channel.txSelect();</span><br><span class="line">channel.txCommit();</span><br><span class="line">channel.txRollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="2020/04/14/docker/"/>
      <url>2020/04/14/docker/</url>
      
        <content type="html"><![CDATA[<p><strong>Docker</strong></p><a id="more"></a><h2 id="Docker的使用"><a href="#Docker的使用" class="headerlink" title="Docker的使用"></a>Docker的使用</h2><h3 id="获取容器"><a href="#获取容器" class="headerlink" title="获取容器"></a>获取容器</h3><p><code>$ docker pull ubuntu</code></p><h3 id="启动停止容器"><a href="#启动停止容器" class="headerlink" title="启动停止容器"></a>启动停止容器</h3><p><code>$ docker run -it ubuntu /bin/bash</code>, <strong>-i</strong> :交互式操作  <strong>-t</strong>：终端</p><p><code>$ docker ps -a</code>：查看所有的容器</p><p><code>$ docker run -itd --name name-test image /bin/bash</code>, <strong>-d</strong>: 默认不会进入容器，后台运行，使用-d后进入容器的方法：</p><ul><li><strong>docker attach container-id</strong>  ，退出容器会停止容器</li><li><strong>docker exec</strong>，退出不会停止容器</li></ul><p><code>$ docker stop container-id</code>，停止容器</p><p><code>$ docker restart container-id</code> ：重启</p><p><code>$ docker rm -f 容器ID</code>：删除容器</p><p><code>$ docker run -d -P</code>：-P：将容器内部使用的网络端口映射到我们使用的主机上</p><p><code>$ docker run -d -p port:5000</code>：-p： 设置不同端口</p><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p><code>$ docker images</code>：查看所有镜像</p><p><code>$ docker rmi REPOSITORY</code>，删除镜像</p><p><code>$ docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; containerId runoob/ubuntu:v2</code>，根据容器创建镜像, <strong>-m</strong>：描述信息 , <strong>-a</strong>：作者, <strong>runoob/ubuntu:v2</strong>：目标镜像名</p><h2 id="Docker-思想"><a href="#Docker-思想" class="headerlink" title="Docker 思想"></a>Docker 思想</h2><ul><li>集装箱</li><li>标准化 运输方式，存储方式，API接口</li><li>隔离</li></ul><p>特点：轻量，标准，安全。</p><p>一致的运行环境；更快的启动时间；隔离性；弹性收缩，快速扩展；迁移方便；持续集成/持续交互（CI/CD）(Continuous Integration/Continuous Delivery)。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="2020/01/03/linux/"/>
      <url>2020/01/03/linux/</url>
      
        <content type="html"><![CDATA[<p>Linux学习</p><a id="more"></a><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>查看使用最多的五个命令： <code>history | awk &#39;&#123;print $2&#125;&#39; | sort | uniq -c | sort -nr | head -5</code></p><h3 id="文件及目录管理"><a href="#文件及目录管理" class="headerlink" title="文件及目录管理"></a>文件及目录管理</h3><ul><li>touch</li><li>mkdir</li><li>mv</li><li>rm</li><li>cp</li><li>cd</li><li>pwd</li><li>ls</li><li>tree</li><li>find</li></ul><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><ul><li>cat</li><li>more</li><li>less</li><li>head</li><li>tail</li><li>sort</li><li>uniq</li><li>grep</li><li>awk</li></ul><h2 id="查看Java-PID等相关信息"><a href="#查看Java-PID等相关信息" class="headerlink" title="查看Java PID等相关信息"></a>查看Java PID等相关信息</h2><h3 id="获取Java-Pid"><a href="#获取Java-Pid" class="headerlink" title="获取Java Pid"></a>获取Java Pid</h3><ul><li><strong>$ jps</strong>: <strong>-m</strong> main方法, <strong>-l</strong> package名或者应用程序的jar文件完整路径名, <strong>-v</strong> main方法所在的class名,以及传递给jvm的参数</li><li><strong>ps -ef|grep java</strong></li></ul><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>CPU不需要将数据从某处内存复制到另一个特别区域。<br>传统数据传输要经过4次拷贝，两次DMA(direct memory access) copy,两次CPU copy<br>常见零拷贝：</p><ul><li>mmap内存映射: 一次cpu copy，两次DMA copy</li><li>sendfile:  一次cpu copy，两次DMA copy</li><li>Sendfile With DMA Scatter/Gather Copy:  0次cpu copy，两次DMA copy</li><li>splice: 0次cpu copy，两次DMA copy </li></ul><h2 id="用户态与核心态"><a href="#用户态与核心态" class="headerlink" title="用户态与核心态"></a>用户态与核心态</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/20620445/answer/914803999">https://www.zhihu.com/question/20620445/answer/914803999</a><br>零拷贝： <a href="https://zhuanlan.zhihu.com/p/78869158">https://zhuanlan.zhihu.com/p/78869158</a> </p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式微服务</title>
      <link href="2019/11/18/spring-cloud/"/>
      <url>2019/11/18/spring-cloud/</url>
      
        <content type="html"><![CDATA[<p>分布式微服务</p><a id="more"></a><h2 id="Eureka与Zookeeper"><a href="#Eureka与Zookeeper" class="headerlink" title="Eureka与Zookeeper"></a>Eureka与Zookeeper</h2><p>CAP定理： <strong>Consistency</strong>（）一致性 、<strong>Availability</strong>（可用性）、 <strong>Partition tolerance</strong>（分区容错性，分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足<strong>一致性</strong>和<strong>可用性</strong>的服务，除非是整个网络环境都发生了故障。）</p><p><strong>base</strong>理论: <strong>Basically Available</strong> 基本可用, <strong>Soft-State</strong> 软状态; <strong>Eventually Consistent</strong> 最终一致性。 </p><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><p>Eureka基于AP协议，采用Peer to Peer 对等通信。</p><h3 id="Zookeepe"><a href="#Zookeepe" class="headerlink" title="Zookeepe"></a>Zookeepe</h3><p>Zookeeper基于CP协议，基于ZAB（Zookeeper Atomic Broadcast）来保证一致性，选取leader来管理通信。<br>分布式协调，分布式锁，注册中心</p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="XA方案"><a href="#XA方案" class="headerlink" title="XA方案"></a>XA方案</h3><h3 id="TCC方案"><a href="#TCC方案" class="headerlink" title="TCC方案"></a>TCC方案</h3><h3 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h3><h3 id="可靠消息最终一致性"><a href="#可靠消息最终一致性" class="headerlink" title="可靠消息最终一致性"></a>可靠消息最终一致性</h3><h3 id="最大努力通知方案"><a href="#最大努力通知方案" class="headerlink" title="最大努力通知方案"></a>最大努力通知方案</h3><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>数据库，redis redlock，zookeeper</p><h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h2><ul><li>固定窗口计数器算法<ul><li>将时间划为多个窗口，22:00:00–22:00:01–22:00:02</li><li>每个窗口每次请求就加一</li><li>如果计数器超过了限制数量，则将本窗口的所有请求丢弃，等到达下一秒时，计数器重置</li></ul></li><li>滑动窗口计数器</li><li>漏桶<ul><li>首先有一个容器，每个请求就放入容器中</li><li>容器以固定速率释放请求</li><li>容器满了，请求会被丢弃</li></ul></li><li>令牌桶<ul><li>令牌以固定速率生成</li><li>生成的令牌放入桶中，如果令牌桶满了多余的令牌直接丢弃，当有请求时，会先尝试从桶中获取令牌，取到了令牌才能执行</li><li>桶空了，尝试获取令牌的请求被丢弃</li></ul></li></ul><h2 id="Spring-Cloud-组件"><a href="#Spring-Cloud-组件" class="headerlink" title="Spring Cloud 组件"></a>Spring Cloud 组件</h2><h3 id="Eureka-1"><a href="#Eureka-1" class="headerlink" title="Eureka"></a>Eureka</h3><h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><h3 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h3><h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><h3 id="Hystrix客户端弹性模式"><a href="#Hystrix客户端弹性模式" class="headerlink" title="Hystrix客户端弹性模式"></a>Hystrix客户端弹性模式</h3><ul><li><strong>客户端负载均衡模式（ client load balance ）</strong></li><li><strong>断路由模式（ circuit breaker ）</strong></li><li><strong>后备模式（ fallback ）</strong></li><li><strong>舱壁模式（ bulkhead ）</strong></li></ul><h3 id="使用Hystrix实现断路由"><a href="#使用Hystrix实现断路由" class="headerlink" title="使用Hystrix实现断路由"></a>使用Hystrix实现断路由</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LicenseService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getLicenseByOrg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@HystrixCommand</span> 超时时间默认<span class="number">1000</span>ms, 错误显示：getLicenseByOrg time-out and fallback failed.</span><br><span class="line"><span class="meta">@HystrixCommand(commandProperties =&#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;12000&quot;)</span></span><br><span class="line"><span class="meta">&#125; )</span>；设置超时为<span class="number">12</span>秒</span><br><span class="line">         </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="后备处理"><a href="#后备处理" class="headerlink" title="后备处理"></a>后备处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;buildFallbackLicenseList&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getLicenseByOrg</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">buildFallbackLicenseList</span><span class="params">()</span></span>&#123;</span><br><span class="line">      List&lt;String&gt; fallbackString = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      fallbackString.add(<span class="string">&quot;请求失败了&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> fallbackString;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="舱壁模式"><a href="#舱壁模式" class="headerlink" title="舱壁模式"></a>舱壁模式</h3><p>通常需要调用多个微服务来完成特定的任务，在不使用舱壁模式的情况下，这些默认调用是使用同一批线程来执行调用的，这些线程是为了处理Java整个容器的请求而预留的。在存在大量请求的条件下，同时堵塞请求，最早导致Java容器崩溃。舱壁模式将远程资源调用隔离在自己的线程中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(threadPoolKey = &quot;licenseByOrgThreadPool&quot;,</span></span><br><span class="line"><span class="meta">         threadPoolProperties = &#123;</span></span><br><span class="line"><span class="meta">             @HystrixProperty(name = &quot;coreSize&quot;, value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">             @HystrixProperty(name = &quot;maxQueueSize&quot;, value = &quot;20&quot;)</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">         &#125;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getLicenseByOrg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="Nginx与Ribbon"><a href="#Nginx与Ribbon" class="headerlink" title="Nginx与Ribbon"></a>Nginx与Ribbon</h2><p>在 <code>Nginx</code> 中请求是先进入负载均衡器，而在 <code>Ribbon</code> 中是先在客户端进行负载均衡才进行请求的。</p><h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><ul><li>轮询策略（<strong>Round Robin</strong>）：依次分配给后台服务器。</li><li>加权轮询（<strong>Weighted Round Robin</strong>）：加权本质是一种带优先级的方式，加权轮询就是一种改进的轮询算法，轮询算法是权值相同的加权轮询。</li><li>随机策略（<strong>RandomRule</strong>）：从所有可用中选一个。</li><li>哈希与一致性哈希</li><li>重试策略：先按照 <strong>RoundRobinRule</strong> 策略获取 <strong>provider</strong>，若获取失败，则在指定的时限内重试。默认的时限为 500 毫秒。</li></ul><p>熔断，降级，限流，隔离，超时处理</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="2019/11/12/redis/"/>
      <url>2019/11/12/redis/</url>
      
        <content type="html"><![CDATA[<p><strong>Redis</strong></p><a id="more"></a><ul><li>纯内存操作</li><li>使用IO多路复用技术</li><li>非CPU密集型任务</li><li>单线程处理请求</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="Strings字符串"><a href="#Strings字符串" class="headerlink" title="Strings字符串"></a>Strings字符串</h3><p>set,get</p><p><strong>set key value</strong>  /  <strong>get key</strong>  /  <strong>MSET key1 value1 key2 value2</strong>  / <strong>MGET key1 key2</strong> /  <strong>GETSET key value1</strong> 返回value</p><p><strong>Redis 规定了字符串的长度不得超过 512 MB。</strong></p><h3 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h3><p>lpush, rpush, lpop, rpop, lrange</p><p><strong>lpush list value</strong>  / <strong>rpush list value</strong>  /  <strong>lrange mylist 0 -1</strong> / <strong>LPOP list 队列是先进先出的数据结构 读取一次value</strong>  /  <strong>RPOP books 栈是先进后出的数据结构</strong></p><h3 id="Hash哈希"><a href="#Hash哈希" class="headerlink" title="Hash哈希"></a>Hash哈希</h3><p>hset, hget, hgetall</p><p><strong>扩容</strong>： 渐进式<code>rehash</code>，保留两个新旧<strong>hash</strong>结构，扩容的数组为原来的两倍，如果redis正在做<strong>bgsave</strong>，尽量不去扩容，如果长度达到一维数组的5倍，强制扩容。</p><p>底层数据结构：ziplist与hashtable</p><p>ziplist结构：zlbytes, zltail, alten, entry，···</p><p>两个条件：hash-max-ziplist-entries 512  数据项(filed-value)超过512; hash-max-ziplist-value 64 value长度超过64; </p><p>缺点：每次插入修改可能会造成内存拷贝，数据够多时查询速度降低。</p><h3 id="sets与sorted-sets-集合与有序集合"><a href="#sets与sorted-sets-集合与有序集合" class="headerlink" title="sets与sorted sets 集合与有序集合"></a>sets与sorted sets 集合与有序集合</h3><p>sadd, spop, smembers, sunion;<br>zadd, zrange, zrem, acard; </p><p>skipList: <a href="http://zhangtielei.com/posts/blog-redis-skiplist.html">http://zhangtielei.com/posts/blog-redis-skiplist.html</a></p><h3 id="bitmaps"><a href="#bitmaps" class="headerlink" title="bitmaps"></a>bitmaps</h3><p>bloom filter 布隆过滤器</p><p><strong>bf.add</strong> / <strong>bd.madd</strong> / <strong>bf.mexists</strong></p><h3 id="hyperloglogs"><a href="#hyperloglogs" class="headerlink" title="hyperloglogs"></a>hyperloglogs</h3><h2 id="KEYS-和-SCAN"><a href="#KEYS-和-SCAN" class="headerlink" title="KEYS 和 SCAN"></a>KEYS 和 SCAN</h2><ul><li><p><strong>KEYS pattern</strong></p><p>时间复杂度为O(N)，但恒定时间短，在40毫秒内可扫描百万个key。当redis中的key非常多时，对于内存的消耗和redis服务器都是一个隐患。</p></li><li><p><strong>SCAN cursor [MATCH pattern] [COUNT count]</strong></p><p><code>scan 0 MATCH *1* COUNT 1000</code>，<strong>count</strong>控制返回多少元素</p></li></ul><h2 id="hash与一致性hash"><a href="#hash与一致性hash" class="headerlink" title="hash与一致性hash"></a>hash与一致性hash</h2><p>在Redis集群，多个主情况下，进行数据的随机存储。</p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>假设有5个主Redis库，hash(data)%5，来确定服务器。但在服务器数量出现变动时，hash会变得不可靠，无法从缓存中获取数据，则会向数据库请求数据。</p><h3 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h3><p>一致性hash对2^32取模，将整个哈希值空间组成一个虚拟的圆环（0-2^32-1）,称为hash环;<br>根据key计算，确定在环上的位置，沿顺时针方向向前查找，第一台服务器就是定位到的服务器。</p><h2 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h2><p>redis有16384个hash槽(Slot). 建议最多1000个master。Redis Cluster 会对key使用CRC16算法计算hash，然后对16384取模来确定key所属槽（hash tag会打破这个规则，保证多个键被分配到同一个槽）。</p><h2 id="淘汰机制"><a href="#淘汰机制" class="headerlink" title="淘汰机制"></a>淘汰机制</h2><p>过期策略： 惰性删除：假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被 redis 给删除掉。</p><p>定期删除：redis 默认是每隔 100ms 就<strong>随机抽取</strong>一些设置了过期时间的 key，检查其是否过期。</p><p><code>maxmemory</code>，最大内存设置，达到后会触发淘汰机制。</p><ul><li><p><code>volatile-lru(Least Recently Used)</code>： 从设置过期时间中选最少使用的淘汰</p><p>一个FIFO队列</p><ul><li>新数据插入链表头部</li><li>每当缓存命中时，将数据移至链表头部</li><li>当链表满的时候，丢弃</li></ul></li><li><p><code>volatile-ttl(time to live)</code>:  从设置过期时间中选将要过期的淘汰</p></li><li><p><code>volatile-random</code>: 从设置过期时间中随机淘汰</p></li><li><p><code>volatile-lfu</code>: 从设置过期时间中淘汰不经常使用的</p><p><strong>Ilfu-log-factor 10</strong></p><p><strong>lfu-decay-time 1</strong>：counter随时间的递减速度</p></li><li><p><code>allkeys-lru</code>: 当内存不足以容纳新数据时，移除最少使用的</p></li><li><p><code>allkeys-random</code>: 随机淘汰</p></li><li><p><code>allkeys-lfu(Least Frequently Used)</code>: 移除不经常使用的</p></li></ul><h2 id="保证缓存与数据库一致性"><a href="#保证缓存与数据库一致性" class="headerlink" title="保证缓存与数据库一致性"></a>保证缓存与数据库一致性</h2><ul><li><p><strong>读请求和写请求串行化</strong>，串到一个<strong>内存队列</strong>里去。</p></li><li><p><strong>Cache Aside Pattern</strong>：</p><p>读的时候，先读缓存，没有的话，读数据库，然后将取出的数据放入缓存。</p><p>更新的时候，先更新数据库，再删除缓存。</p></li><li><p>最初级的缓存不一致问题及解决方案</p><p>问题：更新数据库成功，删除缓存失败。</p><p>解决：先删除缓存，再更新数据库。</p></li><li><p>复杂的缓存不一致问题</p><p>问题：先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong>查到了修改前的旧数据</strong>，放到了缓存中。</p></li></ul><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>save 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。`</p><p>bgsave原理: fork和cow(copy on write);fork创建子线程，cow与父进程共享写数据。</p><h3 id="AOF-append-only-file"><a href="#AOF-append-only-file" class="headerlink" title="AOF(append-only file)"></a>AOF(append-only file)</h3><p>开启： <code>appendonly</code> yes<br>不同持久化方式：</p><ul><li>appendsync always #每次修改就写入</li><li>appendsync everysec #没分钟同步一次 </li><li>appendsync no # 让操作系统决定何时同步</li></ul><p>提供了Rewrite功能，可以重写AOF文件，只保留能把数据更新到最新的结果集，可通过<code>bgrewriteaof</code>命令来触发。</p><ul><li><code>auto-aof-rewrite-percentage 100</code> 增长达到100%</li><li><code>auto-aof-rewrite-min-size 64mb</code> 没超过64M 不重写</li></ul><h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>重启<strong>redis</strong>时使用<strong>rdb</strong>来恢复会丢失大量数据，使用<strong>AOF</strong>日志重放，性能会比<strong>rdb</strong>慢很多。</p><h2 id="Pipelining"><a href="#Pipelining" class="headerlink" title="Pipelining"></a>Pipelining</h2><p>执行连续且无相关性的命令。</p><h2 id="热点数据处理"><a href="#热点数据处理" class="headerlink" title="热点数据处理"></a>热点数据处理</h2><p>防止大量请求同一台机器上的key.</p><ul><li>本地缓存</li><li>proxy 计算</li></ul><h2 id="缓存穿透、缓存击穿与缓存雪崩"><a href="#缓存穿透、缓存击穿与缓存雪崩" class="headerlink" title="缓存穿透、缓存击穿与缓存雪崩"></a>缓存穿透、缓存击穿与缓存雪崩</h2><ul><li><p><strong>缓存穿透</strong>： 获取不存在的数据。就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上。</p><p>解决方法：</p><ul><li>缓存无效key</li><li>不隆过滤器：把所有可能存在的请求的值都存放在布隆过滤器中。</li></ul></li><li><p><strong>缓存击穿</strong>： 热点key失效的瞬间，持续的大并发就穿破缓存。</p></li><li><p><strong>缓存雪崩</strong>：缓存同一时间大面积失效，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>解决方法：设置不同的过期时间，防止同一时间大量key失效。</p><ul><li>事前：尽量保证redis集群高可用，发现宕机尽快补上。选择合适的淘汰机制。</li><li>事中：限流与降级</li><li>事后：利用 redis 持久化机制保存的数据尽快恢复缓存</li></ul></li></ul><h2 id="集群中查找key"><a href="#集群中查找key" class="headerlink" title="集群中查找key"></a>集群中查找key</h2><p>cluster nodes<br>cluster keyslot key<br>cluster slot</p><h2 id="队列与延时队列"><a href="#队列与延时队列" class="headerlink" title="队列与延时队列"></a>队列与延时队列</h2><p>队列可以用list来实现，rpush产生消息，lpop消费消息，没消息时适当sleep，也可以用blpop.<br>延时队列 使用sortedset，拿时间戳做score。消息内容作为key，zrangebyscore来获取数据。</p><h2 id="redis与memcached的区别"><a href="#redis与memcached的区别" class="headerlink" title="redis与memcached的区别"></a>redis与memcached的区别</h2><ol><li>redis支持更丰富的数据类型</li><li>redis支持持久化</li><li>redis支持集群</li><li>redis单线程多路IO复用 </li></ol><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p><code>slave-server-stale-data=no</code>，复制时从不响应，返回SYNC with master in progress<br><code>repl-timeout</code>，超时时间<br><code>repl-ping-slave-period</code>, 心跳检查频率</p><h2 id="Redis集群搭建"><a href="#Redis集群搭建" class="headerlink" title="Redis集群搭建"></a>Redis集群搭建</h2><pre>sudo ufw allow 6379</pre><p>sudo iptables -A INPUT -p tcp –dport 6379 -j ACCEPT</p><p>cluster-enabled yes<br>cluster-config-file nodes.conf<br>cluster-node-timeout 5000<br>appendonly yes</p><p><code> ../src/redis-cli --cluster create 192.168.1.39:7000 192.168.1.39:7001 192.168.1.39:7002 192.168.1.39:7003 192.168.1.39:7004 192.168.1.39:7005 --cluster-replicas 1</code></p><h2 id="Redis-大key问题"><a href="#Redis-大key问题" class="headerlink" title="Redis 大key问题"></a>Redis 大key问题</h2><p>问题： 读写时间过长，阻塞线程</p><p>可以通过 redis-cli –bigkeys与scan命令查找，或者Redis-rdb-cli工具。</p><p>4.0后引入memory usage命令和lazyfree机制</p><p>1几种数据类型，使用方式，场景  2sorted set底层原理，和常用场景。3redis分布式锁，红锁。4击穿击透雪崩，及其预防。5lru算法 6大key的查找清除。7redis单线程还能这么快的原因，io多路复用。8redis集群分片</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5d8f0f7de51d4578323d51d0">https://juejin.im/post/5d8f0f7de51d4578323d51d0</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql学习</title>
      <link href="2019/11/08/mysql/"/>
      <url>2019/11/08/mysql/</url>
      
        <content type="html"><![CDATA[<p>MySQL </p><a id="more"></a><h2 id="DDL-DML-DCL-TCL"><a href="#DDL-DML-DCL-TCL" class="headerlink" title="DDL DML DCL TCL"></a>DDL DML DCL TCL</h2><p>DDL: Data Definition Language. create/alter/drop/truncate/comment/rename<br>DML: Data Manipulation Language. select/update/insert/delete<br>DCL: Data Control Language. grant/revoke<br>TCL: Transactional Control Language. commit/rollback/ </p><h2 id="事物的四大特性-ACID"><a href="#事物的四大特性-ACID" class="headerlink" title="事物的四大特性(ACID)"></a>事物的四大特性(ACID)</h2><ul><li>原子性(<strong>Atomicity</strong>)： 事务是最小的执行单元，不允许分割，确保动作要么全部完成或全部失败。</li><li>一致性(<strong>Consistency</strong>)： 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。</li><li>隔离性(<strong>Isolation</strong>)： 一个事务所做的动作在最终提交之前，对其它事务不可见。</li><li>持久性(<strong>Durability</strong>)：事务结束后，对数据的修改是永久的。</li></ul><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ul><li><strong>READ_UNCOMMITTED</strong>(读未提交)：</li><li><strong>READ_COMMITTED</strong>(读已提交)：</li><li><strong>REPEATABLE_READ</strong>(可重复度)：</li><li><strong>SERIALIZABLE</strong>(可串行化)：</li></ul><p>隔离级别引发的问题：</p><ul><li>脏读</li><li>不可重复读</li><li>幻读<br>不可重复读的重点在于update和delete，幻读在于insert</li></ul><h2 id="char与varchar的区别"><a href="#char与varchar的区别" class="headerlink" title="char与varchar的区别"></a>char与varchar的区别</h2><p><strong>char</strong>有固定的长度，而<strong>varchar</strong>属于可变长的字符类型</p><h2 id="MySql的null字段"><a href="#MySql的null字段" class="headerlink" title="MySql的null字段"></a>MySql的null字段</h2><p>索引</p><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><strong>索引条件</strong>：</p><ol><li>表的主键外键必须有索引</li><li>经常与其它表链接的字段</li><li>经常出现在where语句中的字段</li><li>选择性高的字段</li><li>索引应该建立在小字段上</li><li>复合索引的建立要仔细分析，尽量使用单字段索引</li><li>频繁进行数据库操作的表，不要建立太多索引</li><li>删除无用索引</li></ol><p><strong>聚集索引与非聚集索引</strong><br>聚集索引：叶子节点存数据，非聚集索引叶子节点存对应数据的指针。</p><p>非聚集索引都是辅助索引，像复合索引、前缀索引、唯一索引。</p><p>InnoDB的二级索引叶节点存放KEY和PK_cols,先找到主键，在根据主键索引找。</p><p>参考：<a href="https://www.jianshu.com/p/486a514b0ded">https://www.jianshu.com/p/486a514b0ded</a></p><p>B+ Tree:<br>内节点不存放数据，只保存key，可以降低树的高度，减少查找过程中磁盘I/O的存取次数，提升索引效率。InnoDB叶子节点存数据，MyISAM存指针。</p><p><strong>mysql一次IO默认16k数据，bigint 8b，root node两索引元素之间的指针默认6b，一个节点大概可以存储1170个索引元素</strong></p><p>删除与新增节点：<a href="https://my.oschina.net/u/3350266/blog/4754844">https://my.oschina.net/u/3350266/blog/4754844</a></p><p>hash索引： </p><ul><li>仅能满足 = in &lt;=&gt;查询，不能使用<strong>范围查询</strong></li><li>不能排序查询</li><li>不能利用部分索引键查询，对于组合索引是把组合索引键合并后一起计算hash值</li><li>不能避免表扫描</li></ul><p>索引注意事项：</p><ul><li>避免在where语句中使用 ！= 或&lt;&gt; 操作符，or连接符，表达式操作，函数操作</li><li>多列索引最左原则（只要最左字段出现在where中，就可以使用索引）</li><li>字符串用引号包起来</li><li>like 以%开头</li><li>不适合键值较少的列</li></ul><p>in 会走索引，但在in类型不一致，或者超过eq_range_index_dive_limit，索引会失效。</p><h3 id="索引回表和索引覆盖"><a href="#索引回表和索引覆盖" class="headerlink" title="索引回表和索引覆盖"></a>索引回表和索引覆盖</h3><p><strong>索引回表</strong>：InnoDB，非聚簇索引的索引树结构，叶子结点存储主键值，然后回表根据主键查找。</p><p><strong>索引覆盖</strong>：只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表。</p><p>参考：<a href="https://www.cnblogs.com/myseries/p/11265849.html">https://www.cnblogs.com/myseries/p/11265849.html</a></p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><ul><li>MyISAM： 不支持事务，表级锁，不支持外键和MVCC</li><li>InnoDB： 支持事务，行级锁和表级锁，默认。</li></ul><h2 id="行锁与表锁"><a href="#行锁与表锁" class="headerlink" title="行锁与表锁"></a>行锁与表锁</h2><p><strong>MyISAM</strong>：支持表锁</p><p><strong>InnoDB</strong>：支持行锁与表锁，默认为行锁，在未使用索引查询字段时升级为表锁。</p><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><ul><li><strong>按锁的粒度划分：</strong> 行锁（<em>粒度最小，开销大，会出现死锁</em>），表锁（<em>开销小，加锁快，锁粒度最大</em>），页锁。</li><li><strong>按锁的使用方式：</strong> 共享锁（<em>S锁</em>），排它锁（<em>X锁</em>）。</li><li><strong>思想上划分：</strong>乐观锁，悲观锁。</li></ul><p>行锁在使用上可划分为：<em>共享读锁</em> 和 <em>排它写锁</em></p><ul><li>共享读锁：当前事务不能修改数据只能执行读操作，其他事务只能对该行数据加S锁不能加X锁。</li><li>排它写锁：当前事务能对该行数据进行读和写操作，其它事务不能对该行数据加任何的锁，既不能读也不能写。</li></ul><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>支持的表级锁有两种：<strong>共享读锁</strong> 和 <strong>独占写锁</strong>。</p><p><strong>表级写锁：</strong>当一个线程获取到<strong>表级写锁</strong>后，只能由该线程对表进行读写操作，别的线程必须等待该线程释放锁以后才能操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lock table 表名 read; -- 显示添加表级读锁</span><br><span class="line">lock table 表名 write; -- 添加表级写锁</span><br><span class="line">unlock table; -- 显式的解锁（当一个事务commit的时候也会自动解锁）</span><br><span class="line"></span><br><span class="line">mysql&gt; show status like &#39;table%&#39;; -- 查看锁竞争情况</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Variable_name              | Value |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Table_locks_immediate      | 3     |</span><br><span class="line">| Table_locks_waited         | 0     |</span><br><span class="line">| Table_open_cache_hits      | 81    |</span><br><span class="line">| Table_open_cache_misses    | 9     |</span><br><span class="line">| Table_open_cache_overflows | 0     |</span><br><span class="line">+----------------------------+-------+</span><br></pre></td></tr></table></figure><p><strong>表级共享读锁：</strong> 当一个线程获取到表级读锁后，该线程只能读取数据不能修改数据，其它线程也只能读，不能写。</p><p><em>MyISAM</em>中读写默认是串行的，可通过设置<code>concurrent_insert</code>的值来并行，默认值有<em>0，1，2</em>。</p><p><em>MyISAM</em>存储引擎中，<em>写</em>请求比<em>读</em>请求优先级高，假如有大量的读写操作进来，会造成读请求长时间的等待，可通过设置<code>low-priority-updates</code>来改变请求的优先级。</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>支持表所与行锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from table lock in share mode;</span><br><span class="line"></span><br><span class="line">select * from table for update;</span><br></pre></td></tr></table></figure><p>执行非索引查询执行的是表锁。 普通索引的查询，也会使用行锁。 </p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>只有在<strong>Innodb</strong>中才会出现，解决方案：尽量对表的执行操作串行化；也可以设置参数<code>innodb_lock_wait_timeout</code>超时时间，也可以打开<code>innodb_deadlock_detect</code>，当发现死锁时自动回滚其中一个事务。</p><h3 id="MVCC-multi-version-concurrency-Control-与-next-key锁"><a href="#MVCC-multi-version-concurrency-Control-与-next-key锁" class="headerlink" title="MVCC(multi-version concurrency Control) 与 next-key锁"></a>MVCC(multi-version concurrency Control) 与 next-key锁</h3><p>MVCC: 在InnoDB中会在每行的数据后面添加两个隐藏值来实现MVCC，一个记录这行数据何时被创建，另一个记录何时过期或者删除，存储的是事务的版本号，每开启一个事务，事务版本号会递增。解决RR级别出现读数据时的幻读的情况，但可能会读到不及时的数据。<br>next-key锁: Gap锁与行锁组成，解决写幻读。</p><p>参考资料: <a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">https://tech.meituan.com/2014/08/20/innodb-lock.html</a></p><h2 id="use-index-与-force-index"><a href="#use-index-与-force-index" class="headerlink" title="use index()与 force index()"></a>use index()与 force index()</h2><p>force index会强制走索引，即使认为全表索引快，like 以%开头不走。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>大表查询优化：</p><h3 id="Limit分页"><a href="#Limit分页" class="headerlink" title="Limit分页"></a>Limit分页</h3><p>在数据偏移量大的情况下，limit性能会急剧下降。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table limit 10000,10</span><br></pre></td></tr></table></figure><p>从表中读取N条记录到数据集中，重复读取N=10000+10，抛弃前面10000条数据，返回剩余10条数据。</p><p><strong>优化：</strong></p><ul><li><p>利用自增索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where id &gt;&#x3D; 10000 limit 10</span><br></pre></td></tr></table></figure></li><li><p>覆盖索引，使用主键索引</p></li></ul><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><ul><li><p><strong>id</strong>: id相同时，执行顺序由上至下；不同时，值越大优先级越高。</p></li><li><p><strong>select_type</strong>: select语句的类型。<code>SIMPLE</code>(简单select，不含子查询和union)，<code>primary</code>(有子查询)，<code>union</code></p></li><li><p><strong>table</strong>: 对应的表</p></li><li><p><strong>partitions</strong>:</p></li><li><p><strong>type</strong>:  ALL, index,  range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）</p><p>参考：<a href="https://mengkang.net/1124.html">https://mengkang.net/1124.html</a></p></li><li><p><strong>possible_key</strong>: 可能使用到的索引</p></li><li><p><strong>key</strong>: 实际使用的索引，可以用PORCE INDEX、USE INDEX来强制使用</p></li><li><p><strong>key_len</strong>: 索引使用的字节数</p></li><li><p><strong>ref</strong>:</p></li><li><p><strong>rows</strong>: 统计行数</p></li><li><p><strong>filtered</strong>:</p></li><li><p><strong>Extra</strong>: 解决查询的详细信息。<code>Using where</code>，<code>Using temporary</code>，<code>Using filesort</code>，<code>Impossible where</code>…</p><ul><li><code>Using where</code>：</li><li><code>Using index</code>：将使用覆盖索引</li><li><code>Using filesort</code>：当查询中有<strong>order by</strong>语句，而且无法利用索引完成排序。</li><li><code>Using index condition</code>：</li><li><code>Using temporary</code>：</li></ul></li></ul><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>数据库自增</p><p>两主模式，奇偶数</p><p>多主模式，号码段</p><p>雪花算法</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>以2的倍数进行扩容。<br>2 =&gt; 4:<br>原先 %2=0变为 %4=0和%4=2双主关系， %2=1的变为%4=1,和%4=3双主关系，解除旧的的双主，为4台机器各增加一主，变为4个双主，最后删除冗余的数据。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>binary log日志有ROW、 Statement和 Mixed三种格式，可通过my.cnf配置文件及 set global binlog_format=’ROW/STATEMENT/MIXED’, show variables like binlog_format 查看。</p><ul><li><code>ROW</code>: 能清晰的记录下每行的修改细节，不记录sql的上下文信息，不会出现procedure、function及trigger等无法正确复制的问题，任何情况下都可以被复制，保证从数据库的一致性。    缺点： 会产生大量的日志内容，alter table时，由于表结构更改，那么该表每一条数据都会记录到日志，等于重建表。</li><li><code>Statement</code>: 每一条修改的sql都会记录在日志，避免记录每一行的变化，能大大减少binlog的日志量，节约IO，提高性能。 缺点：主从复制时可能会出现函数执行不一致的情况。</li><li><code>Mixed</code>： 混合row和statement</li></ul><p><strong>原理</strong>：</p><p><strong>在master上的操作</strong>：有数据发生改变时，会写入binlog（binary-log）中。当salve连接到master时，会启用binlog dump线程，当binlog发生变化会通知slave。</p><p><strong>在slave上的操作</strong>：<strong>I/O</strong>线程，Master 服务器上的 IO 线程根据 Slave 服务器的 IO 线程请求的信息，<br>读取指定 binlog 日志文件指定位置之后的 binlog 日志信息，然后返回给 Slave 端的 IO 线程。<br>返回的信息中除了 binlog 日志内容外，还有本次返回日志内容后在 Master 服务器端的新的 binlog 文件名以及在 binlog 中的下一个指定更新位置，并将新的 binlog 文件名和位置记录到 <strong>master-info</strong>`文件中，会将master传来的<strong>binlog</strong>写入<strong>relay log</strong>中。 SQL线程，读取relay log，写入数据。</p><h3 id="主从同步延迟"><a href="#主从同步延迟" class="headerlink" title="主从同步延迟"></a>主从同步延迟</h3><p>mysql 已支持多线程的主从复制</p><h3 id="主从库配置"><a href="#主从库配置" class="headerlink" title="主从库配置"></a>主从库配置</h3><p>主库：<br>[mysqld]</p><h3 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h3><p>N库到2N到4N，4N到8N。</p><p>##主数据库端ID号<br>server_id = 1<br>##开启二进制日志<br>log-bin=mysql-bin #默认地址 /var/lib/mysql<br>binlog_format=ROW<br>##需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可<br>binlog-do-db = master_db<br>##将从服务器从主服务器收到的更新记入到从服务器自己的二进制日志文件中<br>log-slave-updates<br>##控制binlog的写入频率。每执行多少次事务写入一次(这个参数性能消耗很大，但可减小MySQL崩溃造成的损失)<br>sync_binlog = 10<br>##这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突<br>##auto_increment_offset = 1<br>–#这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突<br>– #auto_increment_increment = 1<br>– #二进制日志自动删除的天数，默认值为0,表示“没有自动删除”，启动时和二进制日志循环时可能删除<br>expire_logs_days = 7<br>–#将函数复制到slave<br>– #log_bin_trust_function_creators = 1</p><p>grant replication slave on <em>.</em> to ‘user’@’从IP’ identified by ‘PASSWORD’;<br>flush privileges;<br>show master status\G; 查看状态</p><p>mysqlbinlog mysql-bin.000003 –base64-output=DECODE-ROWS 查看binlog文件。</p><p>从库：<br>server_id = 2<br>log-bin = D:\Program Files\mysql-8.0.18-winx64\mysql-bin<br>log-slave-updates<br>sync_binlog = 0<br>– #log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行。该模式下在事务提交的时候，不会主动触发写入磁盘的操作<br>innodb_flush_log_at_trx_commit = 0<br>– #指定slave要复制哪个库<br>replicate-do-db = master_db<br>– #MySQL主从复制的时候，当Master和Slave之间的网络中断，但是Master和Slave无法察觉的情况下（比如防火墙或者路由问题）。Slave会等待slave_net_timeout设置的秒数后，才能认为网络出现故障，然后才会重连并且追赶这段时间主库的数据<br>slave-net-timeout = 60<br>log_bin_trust_function_creators = 1</p><p>change master to master_host=’主ip’,master_user=’user’,master_password=’’,master_log_file=’主库状态的File’,master_log_pos=主库状态的Position;</p><p>start slave;</p><p>show slave status\G;</p><h2 id="指令记录"><a href="#指令记录" class="headerlink" title="指令记录"></a>指令记录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status;</span><br><span class="line">innodb_lock_wait_timeout;</span><br><span class="line">SET session transaction isolation level read committed;</span><br><span class="line">show variables like &#39;binlog_format&#39;;</span><br><span class="line">show variables like &#39;binlog_row_image&#39;;</span><br><span class="line">show binlog events in &#39;binlog-filename&#39;;</span><br><span class="line">gtid_mode&#x3D;on</span><br><span class="line">enforce-gtid-consistency&#x3D;true</span><br><span class="line">show global variables like &#39;%gtid%&#39;;</span><br><span class="line"></span><br><span class="line">show variables like &#39;character%&#39;;  -- 查看编码</span><br><span class="line">show variables like &#39;transaction_isolation&#39; -- 查看隔离级别</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html">https://tech.meituan.com/2014/06/30/mysql-index.html</a></p><p>锁：<a href="https://blog.csdn.net/mysteryhaohao/article/details/51669741">https://blog.csdn.net/mysteryhaohao/article/details/51669741</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础第二篇</title>
      <link href="2019/11/06/Java-1/"/>
      <url>2019/11/06/Java-1/</url>
      
        <content type="html"><![CDATA[<p>Java 基础</p><a id="more"></a><blockquote><p>其它文章</p></blockquote><a href="/2019/08/13/java/" title="Java 基础第一篇">Java 基础第一篇</a><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java内存模型试图屏蔽各种硬件和操作系统之间的内存访问差异，实现在各平台下都能达到一致性的内存访问效果。</p><p>Java内存分为工作内存和主内存。<br>定义了8各操作来完成主内存和工作内存的交互工作：</p><ul><li>read： 从主内存读取</li><li>load: 把read的值放入工作内存的变量副本中</li><li>use： 执行引擎使用</li><li>assign： 赋值给工作变量</li><li>store： 把工作内存的值传到主内存</li><li>write： 写入主内存的变量值</li><li>lock</li><li>unlock</li></ul><p>内存模型的三大特征： 原子性、可见性、有序性。</p><h3 id="缓存一致性协议：-MESI"><a href="#缓存一致性协议：-MESI" class="headerlink" title="缓存一致性协议： MESI"></a>缓存一致性协议： MESI</h3><ul><li><strong>Modified</strong>：当前CPU拥有最新数据，与主存不一致</li><li><strong>Exclusive</strong>：只有当前CPU拥有，与主存中的数据一致</li><li><strong>Shared</strong>：共享数据</li><li><strong>Invalid</strong>：数据失效</li></ul><h3 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h3><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><code>List, Set, Map</code>的区别：</p><ul><li><code>List</code>：一组有序不唯一的对象</li><li><code>Set</code>：不允许有重复</li><li><code>Map</code>：键值对，key不能重复</li></ul><p><code>List</code>:</p><ul><li><p><code>ArrayList</code>： 基于动态数组实现，支持快速随机访问（实现了<strong>RandomAccess</strong>接口）,定位查找快,<strong>add(E e)**时间复杂度为</strong>O(1)<strong>，删除和</strong>add(int index, E element)<strong>时间复杂度为</strong>O(n-i)**, 线程不安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_CAPACITY = <span class="number">10</span>; <span class="comment">// 默认初始容量为10</span></span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// 扩容为原来的1.5倍</span></span><br></pre></td></tr></table></figure></li><li><p><code>LinkedList</code>： 基于双向链表实现，只能顺序访问，但可以快速的插入和删除元素，不需要扩容，新增和删除时间复杂度**O(1)**，线程不安全。</p></li><li><p><code>Vector</code>： 与<code>ArrayList</code>类似，但是是线程安全的, 扩容一倍。</p></li></ul><p><code>Set</code>:</p><ul><li><code>TreeSet</code>： 基于红黑树，支持有序操作</li><li><code>HashSet</code>： 基于哈希表实现，支持快速查找，不支持有序操作。仅存储对象，**add()**添加元素</li><li><code>LinkedHashSet</code>：具有<code>HashSet</code>的查找效率，且内部使用双向链表维护元素的插入顺序。</li></ul><p><code>Queue</code>:</p><ul><li><code>PriorityQueue</code>： 基于堆结构实现，可以用来实现优先队列。</li></ul><p><code>Map</code>:</p><ul><li><p><code>TreeMap</code>: 基于红黑树。</p></li><li><p><code>HashMap</code>: 基于哈希表。<strong>null</strong>可以作为key，但只能有一个。默认大小为16，扩容为2的幂次方。</p><p>遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap.forEach(((key, value) -&gt; &#123;&#125;);</span><br><span class="line">                </span><br><span class="line"><span class="keyword">for</span> (String s: HashMap.keySet()) &#123;&#125;         </span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>HashTable</code>: 遗留类，线程安全。默认初始大小为11，扩容为原来的2n+1。</p></li><li><p><code>LinkedHashMap</code>： 使用双向链表来维护元素的顺序。</p></li></ul><p>CopyOnWriteArrayList</p><h3 id="HashMap底层实现"><a href="#HashMap底层实现" class="headerlink" title="HashMap底层实现"></a>HashMap底层实现</h3><p>扩容2点幂次方，原因：</p><p><strong>数据和链表</strong>。通过<strong>key</strong>的<strong>hashCode</strong>经过扰动函数处理后得到<strong>hash</strong>值，然后通过**(n - 1) &amp; hash<strong>来得到当前元素的位置，如何当前位置存在元素，就判断该元素与要存入的</strong>hash<strong>和</strong>key.equals(k)<strong>是否相同，相同就覆盖，如果不相同先判断是否有树结构，则直接添加，如果没有，在链表尾端添加元素，链表长度超过8转位红黑树，转红黑树之前会判断数组的长度是否小于</strong>64(MIN_TREEIFY_CAPACITY)**，如果小于怎先扩容。</p><p>线程不安全解决：<code>ConcurrentHashMap&lt;K,V&gt;</code> 并行度，<code>Collections.synchronizedMap()</code></p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ul><li>单一原则：规定每一个类都应该有一个单一的功能，并且该功能将类完全封装起来，一个类只负责一项职责，只能存在一个导致内变更的原因。</li><li>里氏替换原则：使用基类的地方可以任意使用其子类，能保证子类完美替换基类。子类可以扩展父类的功能，但不能改变父类原有的功能。</li><li>依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</li><li>接口隔离原则：类的依赖关系应该建在最小的接口上，不应该依赖它不需要的接口。</li><li>迪米特原则：类间解耦，一个对象应该其它对象保持最少的了解。</li><li>开闭原则：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化。</li></ul><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><h2 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h2><ul><li>强引用：<code>Object obj = new Object();</code>，属于不可回收资源，垃圾回收器绝不会回收它。</li><li>软饮用：<code>SoftReference softReference = new SoftReference(obj);</code>，可有可无，内存不足会回收。</li><li>弱引用：<code>WeakReference weakReference = new WeakReference(obj)</code>，只要垃圾回收器扫描到就会回收。</li><li>虚引用：<code>PhantomReference phantomReference = new PhantomReference(obj, referenceQueue);</code></li></ul><h2 id="JDK代理与CGLIB代理"><a href="#JDK代理与CGLIB代理" class="headerlink" title="JDK代理与CGLIB代理"></a>JDK代理与CGLIB代理</h2><ul><li><p>java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。JDK动态代理只能对实现了接口的类生成代理，而不能针对类。JDK 的动态代理机制是单一的，它只能代理被代理类的接口中的方法；多接口问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现InvocationHandler接口</span></span><br><span class="line"><span class="comment">// Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 创建对象</span></span><br><span class="line"><span class="comment">// 生成的代理类 public class $Proxy0 extends Proxy implements IServices &#123;&#125;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IServices</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">s</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;default method&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealClass</span> <span class="keyword">implements</span> <span class="title">IServices</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot; RealClass sayHello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot; RealClass doService  &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IServicesHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> IServices iServices;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IServicesHandler</span><span class="params">(IServices services)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.iServices = services;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;proxy start...  &quot;</span>);</span><br><span class="line">Object result = method.invoke(iServices, args);</span><br><span class="line">System.out.println(<span class="string">&quot;proxy end...  &quot;</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">RealClass realClass = <span class="keyword">new</span> RealClass();</span><br><span class="line">IServicesHandler iServicesHandler = <span class="keyword">new</span> IServicesHandler(realClass);</span><br><span class="line">IServices iServices = (IServices) Proxy.newProxyInstance(JdkProxyTest.class.getClassLoader(),</span><br><span class="line"><span class="keyword">new</span> Class[]&#123;IServices.class&#125;, iServicesHandler);</span><br><span class="line">iServices.sayHello();</span><br><span class="line">iServices.s();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，所以该类或方法不能声明称final的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span>       Throwable </span>&#123;</span><br><span class="line"><span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(Obect.class);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> MyMethodInterceptor());</span><br><span class="line"></span><br><span class="line">Obect o = (Obect)enhancer.create();</span><br><span class="line">System.out.println(o.method(<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="2019/08/29/jvm/"/>
      <url>2019/08/29/jvm/</url>
      
        <content type="html"><![CDATA[<p>Java堆内存实践、垃圾回收</p><a id="more"></a><h2 id="堆分析"><a href="#堆分析" class="headerlink" title="堆分析"></a>堆分析</h2><span>堆分析工具仅对堆中活跃的对象有效，因为工具执行时通常会强制执行一次Full GC，会对应用造成影响。在一些情况下，不会释放活跃的对象。</span><h3 id="堆直方图"><a href="#堆直方图" class="headerlink" title="堆直方图"></a>堆直方图</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd process_id GC.class_histogram (仅包含活跃对象)</span></span><br><span class="line"></span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:         12320      331636224  [I</span><br><span class="line">   2:        117379       18508464  [C</span><br><span class="line">   3:         12244        6630456  [B</span><br><span class="line">   4:         94440        2266560  java.lang.String</span><br><span class="line">   5:         67537        2161184  java.util.concurrent.locks.AbstractQueuedSynchronizer$Node</span><br><span class="line">   6:         22865        2012120  java.lang.reflect.Method</span><br><span class="line">   7:         52324        1674368  java.util.concurrent.ConcurrentHashMap$Node</span><br><span class="line">[C: 字符数组  [B 字节数组</span><br></pre></td></tr></table></figure><p><span>$&lt;$ jmap -histo:live process_id</code> 会强制在执行Full GC。<br></span></p><h3 id="dump-堆转储"><a href="#dump-堆转储" class="headerlink" title="dump(堆转储)"></a>dump(堆转储)</h3><p><code>$<$ jmap -dump:live,file=/path/to/heap_dump.hprof process_id</code><br>会在指定目录生成文件heap_dump.hprof，然后可以使用 jhat、jvisualvm、mat等工具来分析。</p><h3 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h3><p>下列情况下，JVM会抛出内存溢出错误</p><ul><li>JVM没有原生内存可以用 </li><li>元空间内存不足</li><li>Java堆本身内存不足</li><li>JVM执行GC耗时太多</li></ul><h4 id="原生内存不足"><a href="#原生内存不足" class="headerlink" title="原生内存不足"></a>原生内存不足</h4><p>下面的消息说明线程栈的原生内存耗尽了：<br><code>Exception in thread "main" java.lang.OutOfMemoryError: unable to create new native thread</code><br>在32的JVM中，一个进程最大的内存是4GB，即使在64位中，也不是无限大的。对堆调优是不能解决问题的。</p><h4 id="元数据区内存不足"><a href="#元数据区内存不足" class="headerlink" title="元数据区内存不足"></a>元数据区内存不足</h4><p>错误消息如下：<br><code>Exception in thread "main" java.lang.OutOfMemoryError: Metaspace</code></p><h4 id="Java-堆内存不足"><a href="#Java-堆内存不足" class="headerlink" title="Java 堆内存不足"></a>Java 堆内存不足</h4><p>当确实是堆本身内存不足时，错误消息会是这样的：<br><code>Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</code><br><span>   一种情况：活跃的对象在配置的堆空间装不下了，可以增大堆空间大小解决。另一种情况，存在内存泄漏，执行分配对象，而没有让不存活的对象退出作用域，增加堆小，只会推迟错误的出现。</span><br>OutOfMemoryError不可预测，可以使用JVM参数来生成dump文件。</p><ul><li><code>-XX:+HeapDumpOnOutOfMemoryError</code>,默认为false，设置为true， JVM 会在抛出 OutOfMemoryError 时创建堆转储。</li><li><code>-XX:HeapDumpPath=<path></code>,dump文件路径，会生成java_pid<pid>.hprof 文件。</li><li><code>-XX:+HeapDumpAfterFullGC</code>，这会在运行一次 Full GC 后生成一个堆转储文件。 </li><li><code>-XX:+HeapDumpBeforeFullGC</code>，这会在运行一次 Full GC 之前生成一个堆转储文件。</li></ul><h4 id="达到GC的开销限制"><a href="#达到GC的开销限制" class="headerlink" title="达到GC的开销限制"></a>达到GC的开销限制</h4><p>错误如下：<br><code>Exception in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded</code><br>当满足下列所有条件时就会抛出该错误。</p><ol><li>花在 Full GC 上的时间超出了 -XX:GCTimeLimit=N 标志指定的值。其默认值是 98（也就是，如果 98% 的时间花在了 GC 上，则该条件满足）。</li><li>一次 Full GC 回收的内存量少于 -XX:GCHeapFreeLimit=N 标志指定的值。其默认值是 2，这意味着如果 Full GC 期间释放的内存不足堆的 2%，则该条件满足。</li><li>上面两个条件连续 5 次 Full GC 都成立（这个数值是无法调整的）。</li><li>-XX:+UseGCOverhead-Limit 标志的值为 true （默认如此）。</li></ol><p>请注意，所有四个条件必须都满足。一般来说，应用中连续执行了 5 次以上的 FullGC，不一定会抛出 OutOfMemoryError 。其原因是，即便应用将 98% 的时间花费在执行Full GC 上，但是每次 GC 期间释放的堆空间可能会超过 2%。这种情况下可以考虑增加GCHeapFreeLimit 的值。</p><p>还请注意，如果前两个条件连续 4 次 Full GC 周期都成立，作为释放内存的最后一搏，JVM 中所有的软引用都会在第五次 Full GC 之前被释放。这往往会防止该错误，因为第五次 Full GC 很可能会释放超过 2% 的堆内存（假设该应用使用了软引用）。</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>类装载系统、字节码执行引擎、运行时数据区（内存模型）。</p><p>运行时数据区（内存模型）：</p><p>主要分为：方法区（元数据区）、堆、栈（虚拟机栈和本地方法栈）、程序计数器。</p><p><code>javap -c class</code> 对代码进行反汇编</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>线程私有，线程里的每一个方法代表一个栈帧，FILO先进后出队列。</p><p>栈帧主要存储：局部变量表、操作数栈、动态链接、方法出口。 </p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>常量、静态变量、类信息。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>Serial收集器(常用于单CPU)、Throughput(Parallel)收集器、Concurrent收集器(CMS)、G1收集器和 Z garbage Collector收集器(ZGC)。<br>垃圾回收简单来说由两步构成：查找不在使用的对象，以及释放这些对象管理的内存。有两种方法来查找不在使用的对象：引用计数法和可达性分析。无法通过计数的方式来追踪引用。</p><h3 id="分代垃圾收集器"><a href="#分代垃圾收集器" class="headerlink" title="分代垃圾收集器"></a>分代垃圾收集器</h3><p><code>Object Header：</code> </p><ol><li>Mark World (标记字段)，自身运行时数据：哈希值；GC分代年龄；锁状态标志；线程持有锁；偏向线程ID；偏向时间戳</li><li>Klass Pointer(类型指针)，类的元数据的指针</li><li>数组长度（只有数组对象才有）</li></ol><p>将堆划分为”老年代”(Old Generation or Tenured Generation)和”新生代”(Young Generation)<strong>（2:1）</strong>；新生代又被分为Eden空间和Survivor空间。</p><ul><li><p>Minor GC 新生代触发。新生代分为 Eden和两个Survivor（S0,S1，始终有一个保持为空），8:1:1。一轮Minor GC触发，存活的对象移到S0，Eden清空，下一轮 Minor GC，Eden 的对象移到S1，S0的也移到S1，Eden和S0都为空，存活的对象年龄加一，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15。转移策略:</p><ol><li>年龄阈值。当对象在Survivor区转移次数超过阈值时。</li><li>动态判断。 比如一批对象年龄的总大小大于这块survivor区的50%（-XX:TargetSurvivorRatio 可指定），年龄大于该年龄的对象直接转入老年代。</li><li>大对象直接进入老年代</li></ol></li><li><p>Full GC 老年代空间不足，整个堆</p></li></ul><h3 id="GC-算法"><a href="#GC-算法" class="headerlink" title="GC 算法"></a>GC 算法</h3><p>标记整理(Mark-Compact)，复制(Copying)， 标记清除(Mark-Sweep)</p><h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>32位JVM默认收集器，Minor GC,FulL GC 都会暂停所有应用线程，Full GC会对老年代的对象进行压缩处理。Serial 收集器不能简单地将加号符变成减号符（譬如，使用 -XX:-UseSerialGC ）。在 Serial收集器作为默认收集器的系统上，如果需要关闭 Serial 收集器，可以通过指定另一种垃圾收集器来实现</p><h4 id="Througput"><a href="#Througput" class="headerlink" title="Througput"></a>Througput</h4><p>多CPU和64位JVM默认收集器。使用多线程来处理新生代和老年代，也被称为Paraller收集器，在 Minor GC 和 Full GC 时会暂停所有的应用线程，同时在 Full GC 过程中会对老年代空间进行压缩整理。如果需要，可以使用-XX:+UseParallelGC 、 -XX:+UseParallelOldGC（JDK7） 标志启用 Throughput 收集器。</p><h4 id="CMS-Concurrent-Mark-Sweep"><a href="#CMS-Concurrent-Mark-Sweep" class="headerlink" title="CMS(Concurrent Mark Sweep)"></a>CMS(<strong>Concurrent Mark Sweep</strong>)</h4><p>CMS 收集器设计的初衷是为了消除 Throughput 收集器和 Serial 收集器 Full GC 周期中的长时间停顿。CMS 收集器在 Minor GC 时会暂停所有的应用线程。<br>在Full GC 时不在暂停应用线程，而是使用若干个后台线程定期地对老年代空间进行扫描，及时回收其中不再使用的对象。但不会对老年代进行压缩整理，堆会逐渐碎片化。</p><p>-XX:+UseConcMarkSweepGC</p><p>三色标记，增量更新，ABA问题，</p><p>过程</p><ol><li><p>初始标记：STW(stop the world)，记录老年代与root相连的对象</p></li><li><p>并发标记 ：gc线程与应用线程并行，遍历第一阶段标记出来的存活对象，继续递归遍历老年代，并标记可直接或间接到达的所有老年代存活对象，<strong>为了提高重新标记的效率，本阶段会把这些发生变化的对象所在的Card标识为Dirty</strong>，这样后续就只需要扫描这些Dirty Card的对象，从而避免扫描整个老年代。</p></li><li><p>Concurrent Preclean（并发预清理）：在并发预清洗阶段，<strong>将会重新扫描前一个阶段标记的Dirty对象，并标记被Dirty对象直接或间接引用的对象，然后清除Card标识</strong>。</p></li><li><p>Concurrent Abortable Preclean（可中止的并发预清理）：</p></li><li><p>重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</p></li><li><p>并发清除：开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</p></li><li><p>Concurrent Reset（并发重置）：并发重置阶段，将<strong>清理并恢复在CMS GC过程中的各种状态，重新初始化CMS相关数据结构</strong>。</p></li></ol><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><p>G1 属于Concurrent收集器，收集算法将堆划分为若干个区域。老年代被划分到不同的区域，G1 收集器通过将对象从一个区域复制到另一个区域，完成对象的清理工作，这也意味着在正常的处理过程中，G1 收集器实现了堆的压缩整理（至少是部分的整理）。通过-XX:+UseG1GC可以启用（默认关闭）。</p><h4 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h4><p>JDK11 </p><h3 id="GC-调优"><a href="#GC-调优" class="headerlink" title="GC 调优"></a>GC 调优</h3><p>将新对象留在新生代 <strong>-Xmn</strong>; <strong>-XX:PretenureSizeThreshold</strong> 调整进入老年代的大小，这个参数只在Serial和ParNew下有效；动态年龄设置；</p><h4 id="调整堆大小"><a href="#调整堆大小" class="headerlink" title="调整堆大小"></a>调整堆大小</h4><p>堆大小由两个参数控制：初始值（-Xms N）和最大值(-Xmx N)。</p><h4 id="代空间的调整"><a href="#代空间的调整" class="headerlink" title="代空间的调整"></a>代空间的调整</h4><p>整个堆范围内，不同代的大小划分是由新生代所占用的空间控制的。设置新生代的大小，新生代的大小会根据堆的增大而增大。</p><ol><li>-XX:NewRatio=N。新生代与老年代的占用比例。Initial Young Gen Size = Initial Heap Size / (1 + NewRatio)</li><li>-XX:NewSize=N。 新生代的初始大小</li><li>-XX: MaxNewSize=N。 新生代的最大大小</li><li>-XX:PretenureSizeThreshold  设置老年代大小</li><li>-XmnN。 将 NewSize 和 MaxNewSize 设定为同一个值的快捷方法。</li></ol><h4 id="元空间的调整"><a href="#元空间的调整" class="headerlink" title="元空间的调整"></a>元空间的调整</h4><p>无法提前计算出元空间所需的内存大小。会自动扩展空间。大小可以通过-XX:MetaspaceSize=N和-XX:MaxMetaspaceSize=N<br>来调整。</p><h4 id="控制并发"><a href="#控制并发" class="headerlink" title="控制并发"></a>控制并发</h4><h4 id="自适应调整"><a href="#自适应调整" class="headerlink" title="自适应调整"></a>自适应调整</h4><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>查看前20大小的对象 jcmd pid GC.class_histogram  | head -20<br>查看线程栈 jstack -l pid<br>jstack -l pid |grep “BLOCKED”|wc -l<br>jstack -l pid |grep “Waiting on condition”|wc -l</p><p>线程block问题通常是等待io、等待网络、等待监视器锁等造成，可能会导致请求超时、造成造成线程数暴涨导致系统502等。<br>假设出现这样的问题，主要是关注jstack 出来的BLOCKED、Waiting on condition、Waiting on monitor entry等状态信息。<br>假设大量线程在“waiting for monitor entry”：可能是一个全局锁堵塞住了大量线程。<br>假设短时间内打印的 thread dump 文件反映。随着时间流逝。waiting for monitor entry 的线程越来越多，没有降低的趋势，可能意味着某些线程在临界区里呆的时间太长了，以至于越来越多新线程迟迟无法进入临界区。<br>假设大量线程在“waiting on condition”：可能是它们又跑去获取第三方资源，迟迟获取不到Response，导致大量线程进入等待状态。<br>假设发现有大量的线程都处在 Wait on condition，从线程堆栈看，正等待网络读写，这可能是一个网络瓶颈的征兆，由于网络堵塞导致线程无法运行。</p><p>截取日志文件: sed -n ‘/起始时间/,/结束时间/p’ 日志文件</p><p> jmap -dump:live,file=b.map pid</p><p>显示该进程中最耗CPU的线程 ps -Lfp pid 或 ps -mp pid -o THREAD,tid,time 或 top -Hp pid</p><p>导出：stack pid &gt;&gt; 1.txt</p><p>十六进制转换 printf “%x\n” tid<br>去堆栈中查找54ee的线程 jstack pid | grep 54ee</p><p>打印线程的堆栈信息 jstack pid |grep tid -A 30</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jmap -histo pid | head -20</span></span><br><span class="line"></span><br><span class="line">日志参数：-Xloggc:/root/logs/xxxx-xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20m -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCause -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Java性能权威指南(奥克斯 (Scott Oaks))</li><li><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">https://tech.meituan.com/2017/12/29/jvm-optimize.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/54051496">https://zhuanlan.zhihu.com/p/54051496</a></li><li>线上问题排查 <a href="https://yq.aliyun.com/articles/675285">https://yq.aliyun.com/articles/675285</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="2019/08/22/git/"/>
      <url>2019/08/22/git/</url>
      
        <content type="html"><![CDATA[<p>参考： <a href="https://git-scm.com/book/zh/v2">Git</a> 文档</p><a id="more"></a><h2 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h2><h2 id="Git-工具"><a href="#Git-工具" class="headerlink" title="Git 工具"></a>Git 工具</h2><h3 id="储藏（git-stash）"><a href="#储藏（git-stash）" class="headerlink" title="- 储藏（git stash）"></a>- 储藏（git stash）</h3><p><span><code>git stash</code> 在切换branch之前,可以暂时保存当前branch的更改,使branch变成未更改的状态,随时可以重新应用。</span></p><ul><li><code>$ git status</code> 查看状态</li><li><code>$ git stash or git stash save</code> 存储</li><li><code>$ git stash list</code> 查看现有储藏</li><li><code>$ git stash apply</code> 默认使用最近的储藏并尝试应用 也可在<code>apply</code>后指定</li><li><code>$ git stash apply --index</code> 重新应用暂存的更改</li><li><code>$ git stash drop stash@&#123;0&#125;</code> 移除储藏 </li></ul><p>mvn archetype:generate -DarchetypeCatalog=internal</p><p>Spring bean 替换</p><p>mysql 锁级别 索引条件 </p><p>java 原生线程池</p><p>波那契数列求第n项   树的深度优先遍历  单项链表反转 二分查找</p><p>乐观所，对==账==</p><p>介绍一下我最后的两个项目，一个是东方财务共享研发项目，主要是解决东方航空在财务管理方面的冗余问题，帮助东航建立共享中心，收集单据信息生成工单，主要分为ap/ar两种，生成凭证供财务审核，审核成功交给后端结算。工单生成，工单数据来源有两种，接口和消息队列，Soa（Service-Oriented Architecture 面向服务架构），过来的数据放入接口表中，然后通过定时任务生成工单，负责报表，金税，音像模块，负责前端一些界面的开发，负责项目的部署与维护，带领新人进行开发，进行代码review，进度管理，</p><p>英语介绍</p><p>Get a bachelor’s degree 获得学士学位</p><p>Because I want to change my working environment, I’d like to find a job which is more challenging.</p><p>good afternoon，It’s my great pleasure to have this opportunity to interview。</p><p>my name is ，i come from  ，I have graduated from Hunan University of Technology and my major is Information and Computing Science in June 2016， I am a java developer with about four years of experience ，After graduation, I have two jobs, one in Hande, engaged in the development and implementation of the financial sharing platform, and the other in Youdu Technology, engaged in the development of  SaaS platform，</p><p>I think I’m a good team player and I’m a person of great honesty to others.<br>That’s all. Thank you for giving me the chance</p><p>13045672686</p><p>多线程怎么用 怎么确定分多少线程</p><p>接口很慢怎么解决- 服务降级</p><p>大数据多表关联-查询</p><p>eureka 心跳检测 怎么判断服务出问题</p><p>redis 数据库更新 删与更多区别</p><p>延迟队列</p><p>rabbit mq 死信队列</p><p>mysql 主从同步延迟</p><p>eureka 实现原理</p><p>spring cloud 组件</p><p>jvm 调优</p><p>try cat 异常</p><p>rabbit 镜像队列</p><p>java对象有几种类型，软引用用在哪里</p><p>线程之间通信</p><p>消费者消费金额的前一百</p><p>分布式事务</p><p>尾递归和垃圾回收的比较</p><p><a href="https://mp.weixin.qq.com/s/QbpVrd3_CoUvSs6AFNJPGg">https://mp.weixin.qq.com/s/QbpVrd3_CoUvSs6AFNJPGg</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1MzE4OTU0OQ==&amp;mid=2247484265&amp;idx=1&amp;sn=bf2ad737c983c77dc9acf126de8bcacf&amp;chksm=fbf7eaabcc8063bd4e13c9cc1627415fd4bc048326bce33e452ec96d4b645ef5b5a2ec82b272&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzU1MzE4OTU0OQ==&amp;mid=2247484265&amp;idx=1&amp;sn=bf2ad737c983c77dc9acf126de8bcacf&amp;chksm=fbf7eaabcc8063bd4e13c9cc1627415fd4bc048326bce33e452ec96d4b645ef5b5a2ec82b272&amp;scene=21#wechat_redirect</a></p><p>546    975547546879</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-batch</title>
      <link href="2019/08/20/spring-batch/"/>
      <url>2019/08/20/spring-batch/</url>
      
        <content type="html"><![CDATA[<p><strong>Spring Batch</strong></p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring Batch是一个轻量级，全面的批处理框架，旨在开发对企业系统日常运营至关重要的强大批处理应用程序。<br> 不是一个调度框架,与调度框架一起使用，而不是替换。<br> 应用场景: 读取大量记录 -&gt; 逻辑处理 -&gt; 回写</p><h3 id="Spring-Batch-Architecture"><a href="#Spring-Batch-Architecture" class="headerlink" title="Spring Batch Architecture"></a>Spring Batch Architecture</h3><p><span>三个主要的高级组件: application,core和architecture,Batch Core包含启动和控制批处理作业所需的核心运行时类。它包括 JobLauncher,<br>Job和Step的实现。 Application和Core都 Build 在通用基础架构之上。此基础结构包含常见的读取器和编写器和服务(例如 RetryTemplate),<br>它们由应用程序开发人员（读者和编写者，如 ItemReader 和 ItemWriter ）和核心框架本身（重试，它是自己的库）使用。</span></p><h2 id="配置与运行"><a href="#配置与运行" class="headerlink" title="配置与运行"></a>配置与运行</h2><ul><li>JobBuilderFactory 创建job</li><li>StepBuilderFactory 创建step</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Job job = jobBuilderFactory.get(<span class="string">&quot;exampleJob&quot;</span>)</span><br><span class="line">  .start(step1())</span><br><span class="line">  .next(step2())</span><br><span class="line">  .end()</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><h3 id="Restartability-不允许重新启动"><a href="#Restartability-不允许重新启动" class="headerlink" title="Restartability 不允许重新启动"></a>Restartability 不允许重新启动</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.jobBuilderFactory.get(<span class="string">&quot;exampleJob&quot;</span>)</span><br><span class="line">.preventRestart()</span><br><span class="line">...</span><br><span class="line">.build();</span><br></pre></td></tr></table></figure><h3 id="job-Listener"><a href="#job-Listener" class="headerlink" title="job Listener"></a>job Listener</h3><p>implements JobExecutionListener or use annotations @BeforeJob @AfterJob</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.jobBuilderFactory.get(&quot;exampleJob&quot;)</span><br><span class="line">.listener()</span><br><span class="line">...</span><br><span class="line">.build();</span><br></pre></td></tr></table></figure><h3 id="JobParametersValidator"><a href="#JobParametersValidator" class="headerlink" title="JobParametersValidator"></a>JobParametersValidator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JobParameters jobParameters = <span class="keyword">new</span> JobParametersBuilder()</span><br><span class="line">                .addString(<span class="string">&quot;fileName&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">                .addDate(<span class="string">&quot;date&quot;</span>, <span class="keyword">new</span> Date())</span><br><span class="line">                .toJobParameters();</span><br><span class="line">jobLauncher.run(exampleJob, jobParameters);</span><br><span class="line"><span class="comment">// 使用时间来表示唯一</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">exampleJob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.jobBuilderFactory.get(<span class="string">&quot;exampleJob&quot;</span>)</span><br><span class="line">                     .validator(parametersValidator())</span><br><span class="line">                     ...</span><br><span class="line">                     .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Override-BatchConfigurer"><a href="#Override-BatchConfigurer" class="headerlink" title="Override BatchConfigurer"></a>Override BatchConfigurer</h3><ul><li>JobRepository</li><li>JobLauncher 启动器</li><li>JobRegistry</li><li>PlatformTransactionManager 事务管理</li><li>JobBuilderFactory  job创建</li><li>StepBuilderFactory step 创建</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BatchConfigurer <span class="title">batchConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultBatchConfigurer() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">getTransactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> MyTransactionManager();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JobRepository"><a href="#JobRepository" class="headerlink" title="JobRepository"></a>JobRepository</h4><p>持久化配置,</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">batch:</span></span><br><span class="line">    <span class="attr">initialize-schema:</span> <span class="string">always</span></span><br><span class="line"><span class="comment"># 第一个job执行之前创建Meta-Data Schema(org/springframework/batch/core/migration)    </span></span><br><span class="line"><span class="comment"># 初始化后将值改为 never,否则再次启动的时候会再次创建Meta-Data Schema</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 持久化</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> JobRepository <span class="title">createJobRepository</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    JobRepositoryFactoryBean factory = <span class="keyword">new</span> JobRepositoryFactoryBean();</span><br><span class="line">    factory.setDataSource(dataSource);</span><br><span class="line">    factory.setTransactionManager(transactionManager);</span><br><span class="line">    factory.setIsolationLevelForCreate(<span class="string">&quot;ISOLATION_SERIALIZABLE&quot;</span>);</span><br><span class="line">    factory.setTablePrefix(<span class="string">&quot;BATCH_&quot;</span>);</span><br><span class="line">    factory.setMaxVarCharLength(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> factory.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="configuring-Step"><a href="#configuring-Step" class="headerlink" title="configuring Step"></a>configuring Step</h2><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Batch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="2019/08/13/spring/"/>
      <url>2019/08/13/spring/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>Spring是一个轻量级开发框架，旨在提高开发人员的工作效率以及系统的可维护性。</p><a id="more"></a><h2 id="Spring-模块"><a href="#Spring-模块" class="headerlink" title="Spring 模块"></a>Spring 模块</h2><p>Spring core<br>Spring aop<br>Spring orm<br>Spring web<br>Spring test<br>Spring jdbc<br>Spring jms</p><h2 id="spring-bean的生命周期"><a href="#spring-bean的生命周期" class="headerlink" title="spring bean的生命周期"></a>spring bean的生命周期</h2><p>getBean()的创建过程；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory.getBean(); --&gt; AbstractBeanFactory.getBean() -&gt; doGetBean();</span><br><span class="line">&lt;!-- doGetBean --&gt;</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 返回bean规范名称，别名和工厂引用前缀</span></span><br><span class="line">  <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"><span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 从单列缓存中检查是否有手动注册的bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> DefaultSingletonBeanRegistry#getSingleton 解决循环引用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="comment">// 如果缓存中存在bean</span></span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 对bean进行实例化</span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line"><span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">      <span class="comment">// 循环依赖检查</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">      <span class="comment">// 检查父工厂中是否存在bean的定义</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">      <span class="comment">// 如果beanDefinitionMap中没有，则从parentBeanFactory中获取</span></span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">String nameToLookup = originalBeanName(name);</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line"><span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line"><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 是否进行类型检查</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果bean是子类，则合并父类的属性</span></span><br><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">        <span class="comment">// 处理依赖，遍历初始化依赖</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String scopeName = mbd.getScope();</span><br><span class="line"><span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line"><span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line"><span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Bean容器找到配置文件中 Spring Bean 的定义。</li><li>Bean容器利用Java Reflection API创建一个Bean的实例。</li><li>如果涉及到一些属性值 利用set方法设置一些属性值。</li><li>如果Bean实现了BeanNameAware接口，调用setBeanName()方法，传入Bean的名字。</li><li>如果Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。</li><li>如果Bean实现了BeanFactoryAware接口，调用setBeanFactory()方法，传入BeanFactory对象的实例。</li><li>与上面的类似，如果实现了其他Aware接口，就调用相应的方法。</li><li>如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessBeforeInitialization()方法</li><li>如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。</li><li>如果Bean在配置文件中的定义包含init-method属性，执行指定的方法。</li><li>如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessAfterInitialization()方法</li><li>当要销毁Bean的时候，如果Bean实现了DisposableBean接口，执行destroy()方法。</li><li>当要销毁Bean的时候，如果Bean在配置文件中的定义包含destroy-method属性，执行指定的方法。</li></ul><h2 id="spring-bean-的作用域"><a href="#spring-bean-的作用域" class="headerlink" title="spring bean 的作用域"></a>spring bean 的作用域</h2><p>Singleton prototype request session</p><h2 id="spring-事务"><a href="#spring-事务" class="headerlink" title="spring 事务"></a>spring 事务</h2><p>声明式和编程式</p><p>隔离级别：<code>default</code>, <code>read_uncommitted</code>, <code>read_committed</code>, <code>repeatable_read</code>, <code>serializable</code></p><p>传播行为：</p><ul><li><code>propagation_required</code>, <code>propagation_supports</code>, <code>propagation_mandatory</code></li><li><code>propagation_requires_new</code>, <code>propagation_not_supported</code>, <code>propagation_never</code></li><li><code>propagation_nested</code></li></ul><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><ul><li>客户端发送请求到 <code>DispatcherServlet</code></li><li><code>DispatcherServlet</code>根据请求信心调用<code>HandlerMapping</code>,解析请求对应的<code>Handler</code></li><li><code>HandlerAdapter</code>根据Handler来处理请求</li><li>处理完后，返回一个<code>ModelAndView</code>对象</li><li><code>ViewResolver</code>找到<code>view</code></li><li><code>DispatcherServler</code>将<code>model</code>传给<code>view</code></li><li><code>view</code>返回</li></ul><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h2 id="Spring-IOC-DI"><a href="#Spring-IOC-DI" class="headerlink" title="Spring IOC DI"></a>Spring IOC DI</h2><h2 id="Spring-中的设计模式"><a href="#Spring-中的设计模式" class="headerlink" title="Spring 中的设计模式"></a>Spring 中的设计模式</h2><p>工厂模式，代理模式，单列模式，模板方法模式，包装器模式， 观察者模式， 设配器模式 …</p><h2 id="Spring如何解决循环依赖？为什么要用三级缓存"><a href="#Spring如何解决循环依赖？为什么要用三级缓存" class="headerlink" title="Spring如何解决循环依赖？为什么要用三级缓存"></a>Spring如何解决循环依赖？为什么要用三级缓存</h2><p>参考：<a href="https://cloud.tencent.com/developer/article/1497692">https://cloud.tencent.com/developer/article/1497692</a></p><h2 id="Spring-Boot与Spring"><a href="#Spring-Boot与Spring" class="headerlink" title="Spring Boot与Spring"></a>Spring Boot与Spring</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础第一篇</title>
      <link href="2019/08/13/java/"/>
      <url>2019/08/13/java/</url>
      
        <content type="html"><![CDATA[<p>Java 基础</p><a id="more"></a><blockquote><p>其它文章</p></blockquote><a href="/2019/11/06/Java-1/" title="Java 基础第二篇">Java 基础第二篇</a><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">That means it is not really an interface, but rather a new annotation</span><br><span class="line">type -- to be used as a function modifier, such as @override.</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>面向对象，平台无关，较好的安全性和健壮性，多线程，简单易学，支持网络编程并且方便，编译与解释共存。</p><h2 id="JDK和JRE"><a href="#JDK和JRE" class="headerlink" title="JDK和JRE"></a>JDK和JRE</h2><ul><li><strong>JDK</strong>：<strong>Java Development Kit</strong>，是功能齐全的<strong>Java JDK</strong>。包括了 Java 运行环境(JRE)，一堆 Java 工具 tools.jar 和 Java 标准类库 (rt.jar)。它提供了 Java 的开发环境和运行环境。</li><li><strong>JRE</strong>：<strong>Java Runtime Enviroment</strong>，面向使用者，不是开发者。</li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><strong>封装、继承、多态。</strong></p><ol><li>封装： 把对象属性私有化，同时提供给外界可访问的方法。</li><li>继承：子类继承父类的特征，并且附加一些新的特征。子类拥有父类所有的方法和属性，私有方法和属性也拥有，但不能访问。</li><li>多态：父类引用指向不同的子类对象。</li></ol><h2 id="基本类型与包装类型"><a href="#基本类型与包装类型" class="headerlink" title="基本类型与包装类型"></a>基本类型与包装类型</h2><p>8个基础类型 :</p><ul><li>byte 字节(8 bits)  -128～127</li><li>short (16 bits)  -2^15～2^15-1</li><li>int (32 bits)   -2^31～2^31-1</li><li>long（64 bits） -2^63～2^63-1</li><li>float（32 bits）</li><li>double (64 bits) </li><li>boolean</li><li>char (16 bits)</li></ul><p>包装类型 <code>Byte Short Integer Long Float Double Boolean Character </code></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>与<code>StringBuilder</code>的区别： 都是final类，不允许被继承；String字符串不可变，线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;Java&quot;</span>); <span class="comment">// 创建一个或两个对象 会首先去判断字符常量池</span></span><br><span class="line"></span><br><span class="line">s1.intern(); <span class="comment">// 仅当 s.equals(t) is true 才有 &#123;s.intern() == t.intern()&#125; is &#123;true&#125;</span></span><br></pre></td></tr></table></figure><h2 id="amp-与-amp-amp"><a href="#amp-与-amp-amp" class="headerlink" title="&amp;与&amp;&amp;"></a>&amp;与&amp;&amp;</h2><p>&amp;：位运算符</p><p>&amp;&amp;：逻辑运算符，有短路效应</p><h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><p>类加载器负责在运行时将Java类动态加载到JVM。有三种不同的类加载器：</p><ol><li><code>Bootstrap Class Loader，Java类由java.lang.ClassLoader的实例加载，该实例由bootstrap引导，它主要负责加载JDK内部类，通常是rt.jar和$JAVA_HOME/jre/lib目录中的其他核心库。此外，Bootstrap类加载器还充当所有其他ClassLoader实例的父级。</code></li><li><code>Extension Class Loader；扩展类加载器是引导类加载器的子级，并负责加载标准核心Java类的扩展。</code></li><li><code>Application Class Loader</code><br>类加载遵循委 托模型，当bootstrap和extension class loader 未找到时，尝试自己加载。作为委托模型的结果，很容易确保唯一的类，因为我们总是尝试向上委托。一个类在同一个类加载器中具有<strong>唯一性(Uniqueness)**，而不同类加载器中是允许同名类存在的，这里的同名是指</strong>全限定名相同**。但是在整个JVM里，纵然全限定名相同，若类加载器不同，则仍然不算作是同一个类，无法通过 instanceOf 、equals 等方式的校验。 </li></ol><p>类的执行顺序： 父类静态变量 -》父类静态代码块  -》子类静态变量 -》子类静态代码块 -》父类非静态变量 -》父类非静态代码块 -》父类构造函数 -》子类非静态变量 -》子类非静态代码块 -》子类构造函数。</p><p><code>Class.forname -&gt;(向上委托父类) ClassLoader.loadClass -&gt; (父类加载失败，自己加载)URLClassLoader.findClass</code></p><p>类的加载步骤：装载class文件。链接：验证（检查class文件的正确性）；准备（将为所有静态变量分配内存并为其分配默认值）；解析（将所有符号内存引用替换为“方法区域”中的原始引用）。初始化（所有静态变量将被分配原始值，并且将执行静态块）。</p><p>破坏双亲委派：**SPI(service  provider interface)**；Driver。</p><h2 id="类创建的方式"><a href="#类创建的方式" class="headerlink" title="类创建的方式"></a>类创建的方式</h2><p>通过new实例化；通过反射； 通过clone方法；通过反序列化。</p><h2 id="public-private-protected-default"><a href="#public-private-protected-default" class="headerlink" title="public private protected default"></a>public private protected default</h2><p><strong>private</strong>：类内部</p><p><strong>default</strong>：类内部  同一个包</p><p><strong>protected</strong>：类内部  同一个包  子类</p><p><strong>public</strong>：任何地方</p><h2 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h2><p>重载： 发生在一个类里，方法名相同，参数类型、顺序、个数不同，返回值和修饰符可以不同。<br>重写： 父子类中，方法名和参数必须相同，返回值范围不大于父类。</p><h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><p>无参和有参。父子类中，如果父类声明了有参构造函数，在子类构造函数中没有用super（）声明，则会出现错误。</p><h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h2><ol><li>接口方法只能用 public, abstract, default, static and strictfp（strict float point（精确浮点）修饰类）来修饰，可以有默认实现。抽象类中可以有非抽象方法。</li><li>接口只能有static和final变量。</li><li>一个类可以implements多个接口，但只能继承一个抽象类。</li><li>抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li></ol><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>Throwable</strong>: 异常能被程序本身处理，错误是无法处理。</p><ol><li>Error: 程序无法处理的错误，系统内部错误。</li><li>Exception<ol><li>RuntimeException: 如NullPointerException，ClassCastException、ArrayIndexOutOfBoundsException、ArithmeticException，</li><li>CheckedException: IOException、SQLException</li></ol></li></ol><h2 id="hashCode-与equals-的约定"><a href="#hashCode-与equals-的约定" class="headerlink" title="hashCode()与equals()的约定"></a>hashCode()与equals()的约定</h2><p>equals约定： </p><ul><li>自反性： 对于非null的引用值x，<code>x.equals(x)</code>必须返回true。</li><li>对称性：非null的x和y，<code>x.equlas(y)</code>返回true，<code>y.equals(x)</code>必须返回true。</li><li>传递性： x-y-z，互相equals必须返回true。</li><li>一致性：多次调用的结果和一次一样</li><li><code>x.equals(null)</code>必须返回false。</li><li>覆盖equals时总要覆盖hashCode</li></ul><p>hashCode约定：</p><ul><li>如果两个对象的equals相等，则hashCode也必须相等。</li><li>两个对象有相同的hashcode值，它们equals不一定是相等的。</li><li>一致性</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>类型安全，提供编译检测，兼容，代码可以重复利用，性能高</p><p>泛型中的限定通配符与非限定通配符**</p><p><strong>非限定通配符</strong>：可以用任意类型来替代。</p><p><code>extends</code>：上限通配符，用来限制类型的上限。</p><p><code>super</code>：下限通配符，用来限制类型的下限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; 等于 &lt; T extends Object&gt;</span><br><span class="line">&lt;?&gt; 等于 &lt; ? extends Object&gt;</span><br></pre></td></tr></table></figure><p>如何工作：类型检查；类型擦除；类型擦除和多态性发生了冲突时，则在子类中生成桥方法解决；如果调用泛型方法的返回类型被擦除，则在调用该方法时插入强制类型转。</p><p>类型擦除：兼容，范型只存在代码编译阶段</p><h2 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h2><p><em>匿名内部类中不能定义静态属性、方法；可以访问外部的所有成员。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAnonymousClasses</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greetSomeone</span><span class="params">(String someone)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部类EnglishGreeting实现了HelloWorld接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnglishGreeting</span> <span class="keyword">implements</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">String name = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">greetSomeone(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greetSomeone</span><span class="params">(String someone)</span> </span>&#123;</span><br><span class="line">name = someone;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HelloWorld englishGreeting = <span class="keyword">new</span> EnglishGreeting();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在局部变量frenchGreeting和spanishGreeting的初始化语句中使用匿名类</span></span><br><span class="line">HelloWorld frenchGreeting = <span class="keyword">new</span> HelloWorld() &#123;</span><br><span class="line">String name = <span class="string">&quot;tout le monde&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">greetSomeone(<span class="string">&quot;tout le monde&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greetSomeone</span><span class="params">(String someone)</span> </span>&#123;</span><br><span class="line">name = someone;</span><br><span class="line">System.out.println(<span class="string">&quot;Salut &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HelloWorld spanishGreeting = <span class="keyword">new</span> HelloWorld() &#123;</span><br><span class="line">String name = <span class="string">&quot;mundo&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">greetSomeone(<span class="string">&quot;mundo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greetSomeone</span><span class="params">(String someone)</span> </span>&#123;</span><br><span class="line">name = someone;</span><br><span class="line">System.out.println(<span class="string">&quot;Hola, &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">englishGreeting.greet();</span><br><span class="line">frenchGreeting.greetSomeone(<span class="string">&quot;Fred&quot;</span>);</span><br><span class="line">spanishGreeting.greet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">HelloWorldAnonymousClasses myApp = <span class="keyword">new</span> HelloWorldAnonymousClasses();</span><br><span class="line">myApp.sayHello();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>把Java对象转为字节序列的过程。</p><h3 id="阻止序列化"><a href="#阻止序列化" class="headerlink" title="阻止序列化"></a>阻止序列化</h3><p>private <strong>transient(关键字)</strong> type field;</p><h3 id="序列化协议"><a href="#序列化协议" class="headerlink" title="序列化协议"></a>序列化协议</h3><ul><li><p><strong>COM和CORBA</strong></p></li><li><p><strong>XML&amp;SOAP</strong></p></li><li><p><strong>JSON(Javascript Object Notation)</strong></p></li><li><p><strong>Thrift</strong></p></li><li><p><strong>Protobuf</strong>：</p><p>1、标准的IDL和IDL编译器，这使得其对工程师非常友好。</p><p>2、序列化数据非常简洁，紧凑，与XML相比，其序列化之后的数据量约为1/3到1/10。</p><p>3、解析速度非常快，比对应的XML快约20-100倍。</p><p>4、提供了非常友好的动态库，使用非常简介，反序列化只需要一行代码。</p></li><li><p><strong>Avro</strong></p></li></ul><h3 id="序列化的底层实现"><a href="#序列化的底层实现" class="headerlink" title="序列化的底层实现"></a>序列化的底层实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;temp.out&quot;</span>);</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">    TestObject testObject = <span class="keyword">new</span> TestObject();</span><br><span class="line">    oos.writeObject(testObject);</span><br><span class="line">    oos.flush();</span><br><span class="line">    oos.close();</span><br></pre></td></tr></table></figure><h2 id="常见关键字"><a href="#常见关键字" class="headerlink" title="常见关键字"></a>常见关键字</h2><p>static final synchronized volatile strictfp</p><p>final: 主要用于变量、方法和类。</p><ol><li>对于一个final变量，如果是基础数据类型，初始化后不能更改；如果是引用类型变量，在初始化后不能指向另一个对象。</li><li>声明类时，该类不能被继承，成员方法隐式指定为final。</li></ol><p>static: 修饰变量和方法、静态代码块、静态内部类、静态导包。<br>this: 当前实例。<br>super: 从子类访问父类的变量和方法。<br><strong>this、super 在构造方法中，必须处于首行，不能用于static方法中。</strong></p><p><strong>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</strong></p><p><strong>this是一个指向本对象的指针, 然而super是一个Java关键字。</strong></p><p><strong>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</strong></p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>相邻两元素交换,时间复杂度：O(n) – O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] array = &#123;<span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; array.length -<span class="number">1</span>; i++)&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j&lt; array.length - i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(array[j+<span class="number">1</span>] &lt; array[j])&#123;</span><br><span class="line">         <span class="keyword">int</span> temp = array[j]; </span><br><span class="line">         array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">         array[j+<span class="number">1</span>] = temp;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>找到不小于该元素的位置,时间复杂度：O(n) – O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] array = &#123;<span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arrays.length; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    <span class="keyword">int</span> j = i-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; array[j] &gt; temp)&#123;</span><br><span class="line">      array[j+<span class="number">1</span>]=array[j];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    array[j+<span class="number">1</span>] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>将最小值找出放在首位，然后再从剩余的数列中找出最小的，放入上个最小元素的后面，以此类推。时间复杂度：O(n^2) – O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] array = &#123;<span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> min = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt; array.length; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(array[j] &lt; array[min])&#123;</span><br><span class="line">        min = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[min];</span><br><span class="line">    array[min] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>挑选基准值：从数列中挑出一个元素，称为“基准”（pivot），以该pivot为分割线，小于的放前面，大于的放后面，递归。时间复杂度： O(n log n) – O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first head=0,tail=arr.length-1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> head, <span class="keyword">int</span> tail)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head &gt;= tail)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> i = head; <span class="keyword">int</span> j = tail; <span class="keyword">int</span> pivot = arr[(i + j) / <span class="number">2</span>];</span><br><span class="line">  <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">    <span class="keyword">while</span>(arr[i] &lt; arr[pivot])&#123;</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(arr[j] &gt; arr[pivot])&#123;</span><br><span class="line">      --j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">      <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">      <span class="keyword">int</span> arr[i] = arr[j];</span><br><span class="line">      arr[j] = arr[i];</span><br><span class="line">      ++i;</span><br><span class="line">      --j;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  quickSort(arr, head, j);</span><br><span class="line">  quickSort(arr, i, tail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><ol><li>节点是红色或黑色</li><li>根节点是黑色</li><li>所有叶子都是黑色（叶子是NIL节点）</li><li>每个红色节点必须有两个黑色的子节点</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点</li></ol><h3 id="链表深复制"><a href="#链表深复制" class="headerlink" title="链表深复制"></a>链表深复制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> label;</span><br><span class="line">  RandomListNode next;</span><br><span class="line">  RandomListNode random;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RandomListNode</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.label = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">deepCopy</span><span class="params">(RandomListNode head)</span></span>&#123;</span><br><span class="line">  RandomListNode newHead = <span class="keyword">new</span> RandomListNode(head.label);</span><br><span class="line">  RandomListNode temp = newHead;</span><br><span class="line">  RandomListNode temp2 = head;</span><br><span class="line">  <span class="keyword">while</span>(temp2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    temp2 = temp2.next;</span><br><span class="line">    temp.next = <span class="keyword">new</span> RandomListNode(temp2.label);</span><br><span class="line">    temp = temp.next;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  temp = newHead;</span><br><span class="line">  temp2 = head;</span><br><span class="line">  <span class="keyword">while</span>(temp2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    RandomListNode random = temp2.random;</span><br><span class="line">    RandomListNode cur = newHead;</span><br><span class="line">    <span class="keyword">while</span>(random != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(random.label == cur.label)&#123;</span><br><span class="line">        temp.random = cur;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    temp2 = temp2.next;</span><br><span class="line">    temp = temp.next;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">return</span> newhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表翻转"><a href="#链表翻转" class="headerlink" title="链表翻转"></a>链表翻转</h3><h3 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h3><p><a href="https://github.com/mission-peace/interview/blob/master/src/com/interview/string/SubstringSearch.java">https://github.com/mission-peace/interview/blob/master/src/com/interview/string/SubstringSearch.java</a></p><h2 id="Java-8-新特性"><a href="#Java-8-新特性" class="headerlink" title="Java 8 新特性"></a>Java 8 新特性</h2><ul><li>Lambda表达式和函数式接口(<code>@FunctionalInterface</code>)</li><li>接口的默认和静态方法</li><li>方法引用</li><li>重复注解<code>@Repeatable</code></li><li>Optional 类</li><li>Stream API</li><li>新的 Date-Time API</li><li>JVM 元数据(<strong>Metaspace</strong>)代替永久代<strong>PermGen</strong> space</li></ul><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><ul><li>按流向可分为输出流和输入流。</li><li>按操作单元可分为字节流和字符流。<ul><li>字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元。</li><li>字节流默认不使用缓冲区；字符流使用缓冲区。</li><li>字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。</li></ul></li><li>按照流的角色划分为节点流和处理流。<br>由InputStream/Reader OutputStream/Writer这个抽象类派生。<br>IO模型： NIO、BIO、AIO</li><li>BIO: blocking I/O：同步阻塞I/O模式。提供了<strong>channel</strong>，<strong>selector</strong>，<strong>buffer</strong>(变量：capacity，position 当前已读写的字节数，limit还可以读写的字节数)等抽象。</li><li>NIO: new I/0 or Non-blocking I/O：同步非阻塞I/O。</li><li>AIO: asynchronized I/O：异步非阻塞I/O。</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>参考：<a href="https://www.runoob.com/design-pattern/factory-pattern.html">https://www.runoob.com/design-pattern/factory-pattern.html</a></p><h3 id="单列模式"><a href="#单列模式" class="headerlink" title="单列模式"></a>单列模式</h3><p>破坏单列：反射与反序列化</p><p>反射解决：private Singleton(){ if(singleton != null ){ return new Exception  } }</p><p>反序列化解决：在ObjectInputStream#readOrdinaryObject中，会判断对象是否包含readResolve方法</p><ul><li>懒汉模式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程不安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// double check</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>饿汉模式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p><strong>意图：</strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p><strong>意图：</strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><strong>意图：</strong>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>意图：</strong>为其他对象提供一种代理以控制对这个对象的访问。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程安全：当多个线程访问一个对象时，不需要额外的同步控制或其它的协调操作，调用这个对象的行为都可以获取到正确的结果。</p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>线程基本状态： NEW、RUNNABLE、BLOCKED、WAITING、TIME_WAITING、TERMINATED。</p><p>当<strong>NEW</strong>一个线程后，线程处于<strong>ready</strong>，等获取到了Cpu时间片后处于运行状态。</p><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.setPriority(Thread.MAX_PRIORITY);</span><br></pre></td></tr></table></figure><p><code>Thread.MIN_PRIORITY</code> 1, 最低优先级</p><p><code>Thread.NORM_PRIORITY</code> 5, 普通优先级</p><p><code>Thread.MAX_PRIORITY</code> 10, 最高优先级</p><p><strong>newPriority</strong>只能在最高与最低之间</p><h3 id="多个线程按序执行"><a href="#多个线程按序执行" class="headerlink" title="多个线程按序执行"></a>多个线程按序执行</h3><ol><li>使用<strong>join</strong>/ <strong>join(long millis)</strong></li><li><strong>CountDownLatch</strong>, <code>new CountDownLatch(0)</code></li><li>使用Executors.newSingleThreadExecutor()，单线程提交</li></ol><h3 id="sleep-和wait-的区别和共同点"><a href="#sleep-和wait-的区别和共同点" class="headerlink" title="sleep()和wait()的区别和共同点"></a>sleep()和wait()的区别和共同点</h3><ol><li>sleep没有释放锁</li><li>都可以暂停线程的执行</li><li>Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行</li><li>sleep会自动苏醒，wait也可以设置时间或者notify唤醒</li></ol><p><code>sleep()</code>定义在Thread上，<code>wait()</code>定义在Object上，因为Java锁是对象级别。</p><p><code>sleep()</code>可以在任何地方使用，<code>wait()</code>必须在同步块或同步方法执行。</p><p><code>notify()</code>随机唤醒对象监听器上等待的线程，<code>notifyAll()</code>唤醒所有。</p><p><code>sleep(0)</code>：可以防止将时间片切换到优先级较低的线程。</p><p><code>Thread.yield()</code> 不关注线程优先级</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>优点</strong>： 降低资源消耗；提高响应速度；提高线程的可管理性。</p><p><code>Runnable</code>接口和<code>Callable</code>接口的区别： <code>Callable</code>可以返回结果。<br><code>execute()</code>和<code>submit()</code>的区别： <code>execute()</code>提交不需要返回值的任务；<code>submit()</code>方法用于提交需要返回值的任务，线程池会返回一个Future类型的对象，抛出的异常会保存在成员变量里。</p><p>线程池的创建： 不允许使用<code>Executors</code>去创建，而是通过<code>ThreadPoolExecutor</code>的方式创建。</p><ul><li><code>FixedThreadPool</code>和<code>SingleThreadPool</code>: 允许请求队列的长度为<code>Integer.MAX_VALUE</code>,可能堆积大量的请求从而导致<code>OOM</code>;</li><li><code>CachedThreadPool</code>和<code>ScheduledThreadPool</code>：允许创建的线程数量为<code>Integer.MAX_VALUE</code>，可能会创建大量的线程，从而导致<code>OOM</code>;</li></ul><h4 id="主要参数与拒绝策略"><a href="#主要参数与拒绝策略" class="headerlink" title="主要参数与拒绝策略"></a>主要参数与拒绝策略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                               <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                               <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                               TimeUnit unit,</span><br><span class="line">                               BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                               ThreadFactory threadFactory,</span><br><span class="line">                               RejectedExecutionHandler handler);</span><br></pre></td></tr></table></figure><p><code>keepAliveTime</code>：空闲线程的存活时间。</p><p>当任务大于核心线程时会将任务放入队列，队列满了会去创建新的线程直到设定的最大线程数，最大线程和队列都满了会根据<code>RejectedExecutionHandler</code>来处理，默认<code>AbortPolicy</code>。</p><p><code>AbortPolicy</code>：终止执行，抛出异常。</p><p><code>CallerRunsPolicy</code>：把任务交给当前线程去执行。</p><p><code>DiscardPolicy</code>：丢弃任务。</p><p><code>DiscardOldestPolicy</code>：丢弃最旧的未处理的任务。</p><p><strong>五个运行状态</strong>：<code>RUNNING</code>；<code>SHUTDOWN</code> 会继续执行阻塞队列中的任务；<code>STOP</code>；<code>TIDYING</code> workCount为0；<code>TERMINATED</code>；</p><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p>Synchronized属于重量级锁，依赖操作系统的Mutex Lock来实现monitor监视,JDK 1.6进行了大量优化，减少锁操作的开销。同步块使用monitorenter和monitorexit来表示起始和结束位置，锁计数器为0则可获取。方法使用<code>ACC_SYNCHRONIZED</code>来标记。</p><p>Synchronized同步静态方法和非静态方法的区别：synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！</p><p><code>synchronized</code>与<code>ReentrantLock</code>的区别：</p><ul><li>两者都是可重入锁；<code>synchronized</code>是Java原生关键字锁；<code>ReentrantLock</code>是Java语言层面提供的锁。</li><li><code>synchronized</code>手动加锁；按key锁。<code>ReentrantLock</code>需手动加锁、解锁；支持公平锁；可中断；尝试加锁<code>tryLock()</code>。</li></ul><p><code>synchronized</code>与<code>volatile</code>的区别：</p><ul><li><code>volatile</code>是线程同步的轻量级实现，效率比<code>synchronized</code>好，<code>volatile</code>只能作用于变量。</li><li><code>volatile</code>保证数据的可见性，并不能保证原子性。<code>synchronized</code>两者都能保证。</li><li><code>volatile</code>主要用于解决变量在多线程之间的可见性。<code>synchronized</code>主要解决多线程之间访问资源的同步性。</li></ul><p><strong>并发编程的三个重要特性</strong></p><p><strong>原子性：</strong>一次操作或多次操作要么全部成功要么全部失败</p><p><strong>可见性：</strong>当一个线程对一个共享变量进行了修改，那么其它线程可以立即看到修改的最新值</p><p><strong>有序性：</strong>禁止进行重排序列化</p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p><code>AbstractQueuedSynchronizer</code><br>核心思想： 如果被访问的共享资源是空闲的，则将当前的请求线程设置为有效的工作线程。如果资源被占用，则创建一个FIFO队列来存储线程，CLH队列。</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>参考： <a href="https://blog.reactor.top/2018/01/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%94%81%E4%B9%8BReentrantLock%E6%80%BB%E7%BB%93/">https://blog.reactor.top/2018/01/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%94%81%E4%B9%8BReentrantLock%E6%80%BB%E7%BB%93/</a></p><p><a href="https://juejin.im/entry/5a70a5f951882522b552a374">https://juejin.im/entry/5a70a5f951882522b552a374</a></p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁：多个线程被粗塞，他们中的一个或全部都在等待某个资源的释放。<br>四个条件：<br>    - <strong>互斥</strong>： 只有一个进程能持有资源<br>    - <strong>持有和等待</strong>： 一个进程在等待时持有系统资源<br>    - <strong>禁止抢占</strong>： 不能强制从进程中释放资源<br>    - <strong>循环等待</strong>： 即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源<br>预防和避免：合理分配资源；防止进程在等待情况下占有资源；允许抢占。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>Compare And Swap<br>涉及到的三个操作： 需要进行读写的内存值V；进行比较的A；要写入的新值B。</p><p>无锁编程，缺点：</p><ul><li>ABA问题</li><li>循环时间大</li><li>只能保证一个共享变量的原子操作                    </li></ul><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>默认是10次，可以使用**-XX:PreBlockSpin**来更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AtomicReference cas = <span class="keyword">new</span> AtomicReference();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread cur = Thread.currentThread();</span><br><span class="line">    <span class="keyword">while</span>(! cas.compareAndSet(<span class="keyword">null</span>, cur))&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread cur = Thread.currentThread();</span><br><span class="line">    cas.compareAndSet(cur, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h3><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>是指同一线程在外层方法获取锁后，在进入该线程的内部方法也能获取到锁，前提锁对象是同一个对象或者class。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> <span class="function">pulic <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line">set();</span><br><span class="line">lock.unlock();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line">lock.unlock();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><h3 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h3><h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><h3 id="偏向锁、轻量级锁和重量级锁"><a href="#偏向锁、轻量级锁和重量级锁" class="headerlink" title="偏向锁、轻量级锁和重量级锁"></a>偏向锁、轻量级锁和重量级锁</h3><p>Java对象头包含两部分数据：Mark Word(标记字段)、Klass Pointer(类型指针)。</p><p>Mark Word: 默认存储对象的HashCode，分代年龄和锁标记位信息。</p><p>Klass Pointer： 对象实例的指针</p><ul><li><p>无锁： 标志为 01</p></li><li><p>偏向锁： 指一段同步代码一直被同一个线程访问，那么该线程会自动获取锁，降低获取锁的代价，通过MARK WORLD来标记ThreadId，在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。标志位为0。</p><p>Jdk1.6: -XX:-UseBiasedLocking  来禁用偏向锁，-XX:PreBlockSpin=10 次数，jdk1.7 后由JVM控制。</p></li><li><p>轻量级锁： 标志位为00，将Mark Word拷贝到lock record，在用cas比较；是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。通过CAS和自旋来解决加锁问题，当有第三个线程来访问时升级为重量锁。</p></li><li><p>重量级锁： 标志位为10</p></li></ul><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>减少锁的时间，减少锁的力度，用线程安全的类，使用cas，读些锁，锁粗化</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>由于JVM为每个加载的<code>class</code>创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。这种通过<code>Class</code>实例获取<code>class</code>信息的方法称为反射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取class的Class实例方法</span></span><br><span class="line">Class <span class="class"><span class="keyword">class</span> </span>= String.class;</span><br><span class="line">Class <span class="class"><span class="keyword">class</span> </span>= <span class="string">&quot;&quot;</span>.getClass();</span><br><span class="line">Class <span class="class"><span class="keyword">class</span> </span>= Class.forName(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.cnblogs.com/yougewe/p/10125073.html">https://www.cnblogs.com/yougewe/p/10125073.html</a> </p><p> <a href="http://www.fanyilun.me/2015/10/29/Java%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/">http://www.fanyilun.me/2015/10/29/Java%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/</a></p><h2 id="网络协议，-TCP的三次握手和四次挥手"><a href="#网络协议，-TCP的三次握手和四次挥手" class="headerlink" title="网络协议， TCP的三次握手和四次挥手"></a>网络协议， TCP的三次握手和四次挥手</h2><p>OSI七层协议： 物理层，数据链路层，网络层，运输层，会话层，表示层，应用层。<br>TCP/IP 四层： 网路接口层，网络层，运输层，应用层。</p><p>三次握手： SYN -&gt; SYN/ACK -&gt; ACK<br>四次挥手： client: FIN -&gt; ACK  server: FIN -&gt; ACK</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>锁： <a href="https://tech.meituan.com/2018/11/15/java-lock.html">https://tech.meituan.com/2018/11/15/java-lock.html</a></p><p>自旋锁： <a href="https://segmentfault.com/a/1190000015795906">https://segmentfault.com/a/1190000015795906</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建与基本使用</title>
      <link href="2019/08/13/hexo/"/>
      <url>2019/08/13/hexo/</url>
      
        <content type="html"><![CDATA[<p>hexo + next themes</p><a id="more"></a><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul><li>hexo init [folder]</li><li>hexo s(server)   : 启动服务</li><li>hexo g(generate) : 生成静态文件</li><li>hexo deploy -g   : 部署</li><li>hexo clean       : 清除缓存文件</li></ul><h2 id="更改界面宽度"><a href="#更改界面宽度" class="headerlink" title="更改界面宽度"></a>更改界面宽度</h2><ul><li>一  \themes\next\source\css_variables\custom.styl(<text style="color:#d05">推荐</text>)  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$main</span>-desktop                   = 80%</span><br><span class="line"><span class="variable">$content</span>-desktop                = calc(100% - 252px)</span><br></pre></td></tr></table></figure></li><li>二<ul><li><code style="color:#d05">\themes\next\source\css_common\components\post\post-expand.styl, @media (max-width: 767px),改为1080px;</code></li><li><code style="color:#d05">\themes\next\source\css_variables\base.styl</code>,将下面的值改为自己需要的大小<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$main</span>-desktop                   = 80%</span><br><span class="line"><span class="variable">$content</span>-desktop                = calc(100% - 252px)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>&lt;username&gt;.github.io,username必须为github的用户名</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA</title>
      <link href="2019/08/12/idea/"/>
      <url>2019/08/12/idea/</url>
      
        <content type="html"><![CDATA[<p>idea的一些基本配置记录</p><a id="more"></a><h2 id="避免-import"><a href="#避免-import" class="headerlink" title="避免 import.*"></a>避免 import.*</h2><p>避免在idea中引用同一个包下的类较多,idea直接转成<strong>*</strong>的问题</p><img src="/2019/08/12/idea/idea_import.png" class="" title="import.*"><h2 id="编码配置"><a href="#编码配置" class="headerlink" title="编码配置"></a>编码配置</h2><img src="/2019/08/12/idea/idea-encodings.png" class="" title="import.*"><h2 id="log-level颜色显示"><a href="#log-level颜色显示" class="headerlink" title="log level颜色显示"></a>log level颜色显示</h2><p>run/debug configurations -&gt; VM options : <strong>-Dlog4j.skipJansi=false</strong></p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><em>Relax Your Eyes</em></p><h2 id="run-Coverage-出现-0-classes-0-lines-covered"><a href="#run-Coverage-出现-0-classes-0-lines-covered" class="headerlink" title="run Coverage 出现 0%classes,0% lines covered"></a>run Coverage 出现 0%classes,0% lines covered</h2><p>Ctrl+Alt+F6</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul><li>alibaba-java-coding-guidelines</li><li>findbugs-idea</li><li>Key Promoter X</li><li>intellij-javadoc2</li><li>Maven Helper</li><li>statistic(统计代码)</li><li>PlantUML integration</li><li>MyBatis Log Plugin(把 mybatis 输出的sql日志还原成完整的sql语句)</li><li>mybatis-lite</li><li>Codota</li></ul><h2 id="windows-快捷键"><a href="#windows-快捷键" class="headerlink" title="windows 快捷键"></a>windows 快捷键</h2><ul><li>格式化: Ctrl+Alt+L</li><li>显示方法参数: Ctrl+P</li><li>调出getset: Alt+Insert</li><li>surround with : Ctrl+Alt+T</li><li>文件内搜索/替换: Ctrl+F/R</li><li>全局搜素/替换: Ctrl+Shift+F/R</li><li>查看当前类的结构: Ctrl+F12</li><li>启动: Shift+F10</li><li>debug启动: Shift+F9</li><li>终止运行: Ctrl+F2</li></ul><h2 id="mac-快捷键"><a href="#mac-快捷键" class="headerlink" title="mac 快捷键"></a>mac 快捷键</h2>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
